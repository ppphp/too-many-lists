<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>用太多链表写法学习Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="用太多链表写法学习Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li><a href="first.html"><strong aria-hidden="true">2.</strong> 一个不好的栈</a></li><li><ol class="section"><li><a href="first-layout.html"><strong aria-hidden="true">2.1.</strong> 布局</a></li><li><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> 新建</a></li><li><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> 所有权101</a></li><li><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> 推入</a></li><li><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> 弹出</a></li><li><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> 测试</a></li><li><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> 丢弃</a></li><li><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> 最终代码</a></li></ol></li><li><a href="second.html"><strong aria-hidden="true">3.</strong> 一个可以的栈</a></li><li><ol class="section"><li><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> 选项</a></li><li><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> 泛型</a></li><li><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> 选择</a></li><li><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> 进入遍历</a></li><li><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> 遍历</a></li><li><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> 可变遍历</a></li><li><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> 最终代码</a></li></ol></li><li><a href="third.html"><strong aria-hidden="true">4.</strong> 一个持久化的栈</a></li><li><ol class="section"><li><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> 布局</a></li><li><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> 基本</a></li><li><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> 丢弃</a></li><li><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> 最终代码</a></li></ol></li><li><a href="fourth.html"><strong aria-hidden="true">5.</strong> 一个不好的安全双向队列</a></li><li><ol class="section"><li><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> 布局</a></li><li><a href="fourth-building.html"><strong aria-hidden="true">5.2.</strong> 构建</a></li><li><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> 打破</a></li><li><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> 选择</a></li><li><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> 对称情况</a></li><li><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> 迭代</a></li><li><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> 最终代码</a></li></ol></li><li><a href="fifth.html"><strong aria-hidden="true">6.</strong> 一个不安全的队列</a></li><li><ol class="section"><li><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> 布局</a></li><li><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> 不安全</a></li><li><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> 基础</a></li><li><a href="fifth-extras.html"><strong aria-hidden="true">6.4.</strong> 其他</a></li><li><a href="fifth-final.html"><strong aria-hidden="true">6.5.</strong> 最终代码</a></li></ol></li><li><a href="sixth.html"><strong aria-hidden="true">7.</strong> 一个可以的不安全的双向队列</a></li><li><a href="infinity.html"><strong aria-hidden="true">8.</strong> 一堆傻乎乎的链表</a></li><li><ol class="section"><li><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> 双重单链</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">用太多链表写法学习Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#用太多链表写法学习rust" id="用太多链表写法学习rust">用太多链表写法学习Rust</a></h1>
<blockquote>
<p>有任何问题或想一次性查看所有最终代码吗？
<a href="https://github.com/Gankro/too-many-lists">所有代码都在Github上！</a></p>
</blockquote>
<blockquote>
<p><strong>说明</strong>: 本书当前版本是针对Rust 2018编写的，第一次发布是rustc 1.31 (2018-12-08)
如果你的rust工具链足够新，<code>cargo new</code>创造的Cargo.toml文件应该包含一行
<code>edition = &quot;2018&quot;</code>（如果你在很久以后读到这篇文章，可能看到更大的数字！）。你可以
用旧版工具链，但是会解锁一个隐藏的<strong>困难模式</strong>，你会得到书里没有提到的额外的编译器
报错。哇哦，有意思！</p>
</blockquote>
<p>我经常被问到如何在Rust中实现链表。老实说，答案取决于你的需求是什么，要当场回答这个问
题显然不是超级容易。因此，我决定写这本书来一劳永逸地全面回答这个问题。</p>
<p>在这个系列中，我将通过让你实现6个链表来教你基本和高级的Rust编程。在这样做的过程中，你
应该学会：</p>
<ul>
<li>下列指针类型： <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>*const</code>, <code>*mut</code></li>
<li>所有权、借用、继承可变性、内部可变性、Copy复制性</li>
<li>所有的关键词： struct, enum, fn, pub, impl, use, ...</li>
<li>模式匹配、泛型、析构器</li>
<li>测试</li>
<li>基本不安全Rust</li>
</ul>
<p>是的，链表真是如此的可怕，以至于你在制作它们时要处理所有这些概念。</p>
<p>一切都在侧边栏中（在移动端可能会被折叠），但为了快速参考，这里是我们要做的：</p>
<ol>
<li><a href="first.html">一个不好的单链栈</a></li>
<li><a href="second.html">一个OK的单链栈</a></li>
<li><a href="third.html">一个持久的单链栈</a></li>
<li><a href="fourth.html">一个不好的但安全的双端队列</a></li>
<li><a href="fifth.html">一个不安全的单链队列</a></li>
<li><a href="sixth.html">TODO：一个好的不安全的双端队列</a></li>
<li><a href="infinity.html">Bonus: 一大堆愚蠢的链表</a></li>
</ol>
<p>为了使我们的得到的结果一致，我将写出所有输入终端的命令。我还将使用Rust的标准
包管理器Cargo来开发这个项目。Cargo并不是写Rust程序所必需的，但它比直接使用
rustc要好<em>得多</em>。如果你只是想玩玩，你也可以通过<a href="https://play.rust-lang.org/">play.rust-lang.org</a>
在浏览器中运行一些简单的程序。</p>
<p>让我们开始做我们的项目吧：</p>
<pre><code class="language-text">&gt; cargo new --lib lists
&gt; cd lists
</code></pre>
<p>我们会把每个列表放在一个单独的文件中，这样我们就不会失去任何工作。</p>
<p>需要注意的是，<em>真实的</em>Rust学习经历包括写代码，让编译器对你咆哮，并试图弄清楚
这些咆哮到底是什么意思。我将仔细确保这种情况尽可能频繁地发生。学会阅读和理解
Rust普遍优秀的编译器错误和文档，这对于成为一个高效的Rust程序员来说<em>非常</em>重要。</p>
<p>虽然实际上这是一个谎言。在写这本书的过程中，我遇到的编译器错误<em>远远</em>多于我展示
的。特别是，在后面的章节中，我不会展示很多随机的&quot;打错字（复制粘贴）&quot;的错误，就
是你会在每一种语言中都能遇到的错误。这是一次让编译器向我们尖叫的<em>导游之旅</em>。</p>
<p>我们的进度会很慢，而且老实说，整个过程中我不会很认真。我认为编程应该是有趣的，
哇哈哈! 如果你是那种想要最大化信息密集、严肃、正式内容的人，这本书不适合你。我
所做的一切都不适合你。你错了。</p>
<h1><a class="header" href="#义务公益广告" id="义务公益广告">义务公益广告</a></h1>
<p>我们会完全100％清楚一件事：我就是讨厌链表。恨之入骨。链表是可怕的数据结构。
当然，链表有几个很好的使用案例。</p>
<ul>
<li>你想做<em>很多</em>大列表的拆分或合并。<em>很多</em>。</li>
<li>你正在做一些很棒的无锁并发的事情。</li>
<li>你在写一个内核/嵌入式的东西，想使用一个侵入式列表。</li>
<li>你正在使用纯函数式语言，有限的语义和不能修改东西使得链表比较好用。</li>
<li>......还有更多!</li>
</ul>
<p>但所有这些情况对于任何编写Rust程序的人来说都是<em>超级罕见</em>的。99%的时间你应该只
使用Vec（数组栈），另外1%的时间你应该使用VecDeque（数组双端队列）。由于较少的
内存分配频率、较低的内存开销、真正的随机访问和缓存定位，这些对于大多数工作负载
来说都是公然优越的数据结构。</p>
<p>链表和Trie一样是<em>小众</em>而<em>模糊</em>的数据结构。很少有人会反驳我说Trie是一种小众结
构，你们平均水平程序员在整个生产生涯中很可能永远也不用学会--然而链表却有一些奇
怪的名人地位。我们教每个本科生如何写一个链表。这是唯一的小众集合
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">I couldn't kill from std::collections</a>。它是
<a href="http://en.cppreference.com/w/cpp/container/list"><em>the</em> list in C++</a>!</p>
<p>作为一个社区，我们都应该对链表作为&quot;标准&quot;数据结构说不。它是一个很好的数据结构，
有几个很好的用例，但这些用例是<em>特殊的</em>，而不是常见的。</p>
<p>有几个人显然读了这个PSA的第一段，然后就不读了。比如，他们会试图通过列举我的<em>伟大用
例列表</em>中的一件事来反驳我的论点。就在第一段之后的那件事!</p>
<p>为了让我可以直接链接到详细的论点，下面是我看到的几种反驳的尝试，以及我对它们的回应。
如果你只是想学习一些Rust，欢迎跳到第一章!</p>
<h2><a class="header" href="#性能并不总是重要的" id="性能并不总是重要的">性能并不总是重要的</a></h2>
<p>是的! 也许你的应用程序是I/O瓶颈的，或者相关代码是在一些不重要的冷门的情况下。但这
甚至不是一个使用链表的论点。这是一个使用<em>任何东西</em>的论点。为什么要使用链表呢？使用
链接的哈希图吧!</p>
<p>如果性能不重要，那么应用数组的自然默认值<em>肯定</em>是可以的。</p>
<h2><a class="header" href="#如果你有一个指针在那里他们有o1的分割-追加-插入-删除" id="如果你有一个指针在那里他们有o1的分割-追加-插入-删除">如果你有一个指针在那里，他们有O(1)的分割-追加-插入-删除</a></h2>
<p>没错! 不过正如<a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">Bjarne Stroustrup</a>所指出的，如果获取指针所花费的时间与复制
一个数组中所有元素所花费的时间完全相差无几的话，<em>这实际上并不重要</em>（这确实相当快）。</p>
<p>除非你的工作负载是以拆分和合并成本为主要开销，否则其他每个操作由于缓存效应和代码复杂
度所需要的惩罚会消除任何理论上的收益。</p>
<p><em>但是是的，如果你剖析发现你的应用要花大量的时间在拆分和合并上，你可能从链表中获益。</em></p>
<h2><a class="header" href="#我负担不起摊销" id="我负担不起摊销">我负担不起摊销</a></h2>
<p>你已经进入了一个相当小众的领域--大多数人都能承受摊销。不过，数组<em>在最坏的情况下</em>也是
要摊销的。仅仅因为你使用的是一个数组，并不意味着你有摊销的成本。如果你能预测你要存储
多少元素（甚至有一个上限），你就可以预留所有你需要的空间。根据我的经验，能够预测你需
要多少元素是很常见的。特别是在Rust中，所有的迭代器都会提供一个<code>size_hint</code>，正是针对
这种情况。</p>
<p>那么<code>push</code>和<code>pop</code>将是真正的O(1)操作。而且它们会比链表上的<code>push</code>和<code>pop</code>快得多。你做
一个指针偏移，写入字节，然后递增一个整数。不需要使用任何类型的分配器。</p>
<p>这对低延迟来说如何？</p>
<p><em>但是，是的，如果你不能预测你的负载，那么可以节省在最坏的情况下的延迟!</em></p>
<h2><a class="header" href="#链表浪费的空间更少" id="链表浪费的空间更少">链表浪费的空间更少</a></h2>
<p>嗯，这很复杂。一个“标准”的数组大小调整策略是增长或缩小，使最多一半的数组为空。这确实
浪费了很多空间。特别是在Rust中，我们不会自动收缩集合（如果你只是要把它重新填满，那就
太浪费了），所以浪费的空间可能会接近无穷大!</p>
<p>但这是最坏的情况。在最好的情况下，一个数组栈对整个数组只有三个指针的开销。基本上没有
开销。</p>
<p>而链表则是无条件的浪费每个元素的空间。一个单链列表浪费一个指针，而一个双链列表则浪费
两个指针。与数组不同，相对的浪费与元素的大小成正比。如果你有巨大的元素，这接近于0浪费
。如果你有微小的元素（比如说，字节），那么这可能是高达16倍的内存开销（32位上是8倍）!</p>
<p>实际上，这更像是23倍（32位上是11倍），因为会在字节上添加填充，将整个节点的大小对齐到
指针上。</p>
<p>这也是假设你的分配器的最佳情况：分配和取消分配节点是在密集地进行的，你不会因为碎片化
而损失内存。</p>
<p><em>但是是的，如果你有巨大的元素，不能预测你的负载，并且有一个像样的分配器，就可以节省内
存。</em></p>
<h2><a class="header" href="#我在函数式语言中一直使用链表" id="我在函数式语言中一直使用链表">我在&lt;函数式语言&gt;中一直使用链表。</a></h2>
<p>很好! 在函数式语言中使用链表是超级优雅的，因为你可以在没有任何改变的情况下对它们进行
操作，可以递归地描述它们，而且由于惰性的魔力，还可以使用无限列表。</p>
<p>具体来说，链表是不错的，因为它们代表了一个迭代，而不需要任何可变的状态。下一步只是访
问下一个子列表。</p>
<p>然而需要注意的是，Rust可以在数组上进行模式匹配，并且<a href="https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html">用slices</a>来谈论子数组
! 实际上，它在某些方面甚至比函数式链表更有表现力，因为你可以谈论最后一个元素，甚至“
没有第一和最后两个元素的数组”或其他任何你想要的疯狂的东西。</p>
<p>的确，你不能用分片来<em>构建</em>一个列表。你只能把它们拆开。</p>
<p>为了偷懒，我们改用<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a>。这些可以是无限的，你可以像函数式列表一样对它们进行
映射、过滤、反转和连接，而且这一切都会同样惰性地完成。这里不奇怪：切片也可以被转换成
迭代器。</p>
<p><em>但是是的，如果你限于不可变的语义，链表可以非常好。</em></p>
<p>请注意，我并不是说函数式编程一定很弱或不好。然而它从根本上讲<em>是</em>有语义限制的：你基本
上只允许谈论事情是<em>怎样的</em>，而不允许谈论它们应该<em>怎样做</em>。这实际上是一个<em>特点</em>，因为
它使编译器能够进行大量的<a href="https://wiki.haskell.org/GHC_optimisations#Fusion">怪异变换</a>，并有可能找出<em>最好</em>的方法来做事情，而不用你
担心。然而这是以<em>能够</em>担心为代价的。通常有逃生舱口，但在某些限制下，你又只是在写过程
式代码。</p>
<p>即使是在函数式语言中，当你真正需要数据结构时，你也应该努力为任务使用合适的数据结构。
是的，单链表是你控制数据流的主要工具，但它们对于实际存储一堆数据和查询数据来说是一种
非常糟糕的方式。</p>
<h2><a class="header" href="#链表是构建并发数据结构的好方法" id="链表是构建并发数据结构的好方法">链表是构建并发数据结构的好方法!</a></h2>
<p>是的! 虽然编写一个并发数据结构真的是一个完全不同的野兽，而且不是一件值得轻视的事情。
当然也不是很多人都会考虑去做的事情。一旦写好了一个，你也不是真的选择使用链表。你是选
择使用MPSC队列什么的。在这种情况下，实现策略是相当遥远的!</p>
<p><em>但没错，链表是无锁并发的黑暗世界中的不折不扣的英雄。</em></p>
<h2><a class="header" href="#咕哝咕哝的内核嵌入了一些干扰性的东西" id="咕哝咕哝的内核嵌入了一些干扰性的东西">咕哝咕哝的内核嵌入了一些干扰性的东西。</a></h2>
<p>这很小众。你说的是一种情况，你甚至没有使用你的语言的<em>运行时</em>。这难道不是一个危险的
信号，你在做一些奇怪的事情吗？</p>
<p>这也是非常不安全的。</p>
<p><em>但是肯定的。要在栈上构建你那令人敬畏的零分配列表。</em></p>
<h2><a class="header" href="#迭代器不会因为无关的插入删除而失效" id="迭代器不会因为无关的插入删除而失效">迭代器不会因为无关的插入/删除而失效。</a></h2>
<p>你这舞跳得可真微妙。特别是当你没有垃圾回收器的时候。我可能会说，你的控制流和所有
权模式可能有点太纠结了，这取决于细节。</p>
<p><em>但是是的，你可以用光标做一些非常酷的疯狂的事情。</em></p>
<h2><a class="header" href="#它们很简单而且很适合教学" id="它们很简单而且很适合教学">它们很简单，而且很适合教学</a></h2>
<p>嗯，是的。你正在读一本专门针对这个前提的书。好吧，单链表是非常简单的。双链表可能会
变得有点粗糙，我们会看到。</p>
<h1><a class="header" href="#深呼吸" id="深呼吸">深呼吸</a></h1>
<p>好吧，那就不说了。让我们写一个亿万个链表。</p>
<p>现在开始第一章！</p>
<p><a href="first.html">On to the first chapter!</a></p>
<h1><a class="header" href="#一个不好的单链栈" id="一个不好的单链栈">一个不好的单链栈</a></h1>
<p>这章将是<em>至今</em>最长的一章，因为我们需要介绍所有Rust的基础知识，而且将以“艰难的方式”构建一些东西来
更好地理解这门语言。</p>
<p>我们将把我们的第一个链表放在<code>src/first.rs</code>。我们需要告诉Rust<code>first.rs</code>是我们的库用的东西。需
要做的事是我们把它放在<code>src/lib.rs</code>（Cargo已经给我们创建了）最上面：</p>
<pre><code class="language-rust ignore">// in lib.rs
pub mod first;
</code></pre>
<h1><a class="header" href="#基本数据布局" id="基本数据布局">基本数据布局</a></h1>
<p>好吧，那么什么是链表呢？基本上，它是一堆在堆上的数据片(嘘，内核的人!)，它们依次
指向对方。链表是程序员不应该碰的东西，而函数式程序员却用它来做所有事情。那么，我
们应该向函数式程序员询问链表的定义，这似乎很公平。他们可能会给你类似下面的定义：</p>
<pre><code class="language-haskell">List a = Empty | Elem a (List a)
</code></pre>
<p>其内容大致为“一个链表要么是空的，要么是一个元素，后面是一个链表”。这是一个递归
定义，表示为<em>和类型</em>，这是“一个可以有不同值的类型，这些值可能是不同的类型”的花
哨名字。Rust称和类型为<code>枚举</code>! 如果你来自于类C语言，这正是你所熟悉和喜爱的枚举，
但是是超速的。所以让我们把这个函数定义转录到Rust中吧!</p>
<p>现在，我们将避免使用泛型，保持简单。我们将只支持存储有符号的32位整数:</p>
<pre><code class="language-rust ignore">// in first.rs

// pub says we want people outside this module to be able to use List
pub enum List {
    Empty,
    Elem(i32, List),
}
</code></pre>
<p><em>呼</em>，我被淹没了。我们还是继续编译吧：</p>
<pre><code class="language-text">&gt; cargo build

error[E0072]: recursive type `first::List` has infinite size
 --&gt; src/first.rs:4:1
  |
4 | pub enum List {
  | ^^^^^^^^^^^^^ recursive type has infinite size
5 |     Empty,
6 |     Elem(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `first::List` representable
</code></pre>
<p>好吧，我不知道你是怎么想的，但我确实觉得被函数式编程社区背叛了。</p>
<p>如果我们真正检查一下错误信息（在我们克服了整个背叛的事情之后），我们可
以看到rustc实际上是在告诉我们如何解决这个问题：</p>
<blockquote>
<p>insert indirection (e.g., a <code>Box</code>, <code>Rc</code>, or <code>&amp;</code>) at some point to make <code>first::List</code> representable</p>
</blockquote>
<p>好吧，<code>box</code>。那是什么？让我们谷歌一下<code>rust box</code>...</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std::boxed::Box - Rust</a></p>
</blockquote>
<p>贴在这里...</p>
<blockquote>
<p><code>pub struct Box&lt;T&gt;(_);</code></p>
<p>一个在堆上分配的指针类型。
更多信息参见<a href="https://doc.rust-lang.org/std/boxed/">module-level documentation</a>。</p>
</blockquote>
<p><em>点击链接</em></p>
<blockquote>
<p><code>Box&lt;T&gt;</code>被随意的称为&quot;盒子&quot;，提供了Rust中最简单的堆分配形式。盒子为这种分配提供所有权，并在它们离开范围时放弃它们的内容。</p>
<p>举例</p>
<p>创建盒子：</p>
<p><code>let x = Box::new(5);</code></p>
<p>创建一个递归数据结构：</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}
#}</code></pre></pre>
<blockquote>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{:?}&quot;, list);
}
</code></pre></pre>
<blockquote>
<p>这会打印<code>Cons(1, Box(Cons(2, Box(Nil))))</code>。</p>
<p>递归数据类型一定要是盒子，因为如果他们的Cons的定义向这样：</p>
<p><code>Cons(T, List&lt;T&gt;),</code></p>
<p>它不会运行。这因为链表的大小取决于链表里有几个元素，如果我们不知道Cons要分配多少内存。通过引入有已知大小的盒子，我们知道Cons会有多大。</p>
</blockquote>
<p>哇，呃。这可能是我看过的最相关最有帮助的文档。字面上文档的最重要的事情是<em>确切地
说明我们正在尝试写什么，为什么它不能正常运行，如何修复它</em>。</p>
<p>铛，文档说了算。</p>
<p>好吧，让我们这么做：</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    Elem(i32, Box&lt;List&gt;),
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>哈，他构建了！</p>
<p>...但由于某些原因，实际上这是一个愚蠢的链表定义。</p>
<p>考虑有两个元素的链表：</p>
<pre><code class="language-text">[] = Stack
() = Heap

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty, *junk*)
</code></pre>
<p>有两个关键问题：</p>
<ul>
<li>我们正分配一个只是说“我不是节点”的节点</li>
<li>我们的一个节点不是在堆上分配的。</li>
</ul>
<p>表面上，这两个似乎是相互矛盾的。我们分配一个额外的节点，但是我们其中一个
节点不需要被分配。然而，考虑我们链表可能的以下布局：</p>
<pre><code class="language-text">[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
</code></pre>
<p>在这个布局我们现在不可避免地在堆上分配我们的节点。关键区别是不存在我们第一个
布局的<em>junk</em>。这个垃圾是什么？为了理解，我们将需要查看一个枚举在内存里是如何
布局的。</p>
<p>总的来说，如果我们有一个枚举如下：</p>
<pre><code class="language-rust ignore">enum Foo {
    D1(T1),
    D2(T2),
    ...
    Dn(Tn),
}
</code></pre>
<p>一个Foo会存储一些数字来表示枚举中的哪个<em>变量</em>代表了(<code>D1</code>, <code>D2</code>, .. <code>Dn</code>)。这是枚
举的<em>标签</em>。它也会需要足够的空间存储<em>最大的</em><code>T1</code>, <code>T2</code>, .. <code>Tn</code>（加上一些额外的
空间来满足对齐的需要）。</p>
<p>这里最大的启示是，尽管<code>Empty</code>是一个单一的信息位，但它必然要消耗足够的空间来放置一个
指针和一个元素，因为它要随时准备成为一个<code>Elem</code>。因此第一个布局的堆里多分配了一个元
素，就是满满的垃圾，比第二个布局多消耗了一点空间。</p>
<p>我们的一个节点完全不被分配，也许令人惊讶的是，也比总是分配它<em>更糟糕</em>。这是因为它给我
们提供了一个<em>非统一</em>的节点布局。这对推入和弹出节点没有什么明显的影响，但对拆分和合并
链表有影响。</p>
<p>考虑在两种布局中拆分一个链表：</p>
<pre><code class="language-text">布局1：

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Elem C, ptr) -&gt; (Empty *junk*)

在C处分割：

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty *junk*)
[Elem C, ptr] -&gt; (Empty *junk*)
</code></pre>
<pre><code class="language-text">布局2：

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, ptr) -&gt; (Elem C, *null*)

在C处分割：

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
[ptr] -&gt; (Elem C, *null*)
</code></pre>
<p>布局2的拆分只需要将B的指针复制到堆栈，并将旧的值清空。布局1最终也做同样的事情，
但也要把C从堆中复制到栈中。合并则是反过来的相同过程。</p>
<p>链表的几个好处之一是，你可以在节点本身中构造元素，然后在链表中自由打乱，而无需
移动它。你只需要摆弄一下指针，东西就会被“移动”。布局1破坏了这个属性。</p>
<p>好吧，我有理由相信布局1是坏的。我们如何重写我们的链表？好吧，我们可以做这样的事
情：</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    ElemThenEmpty(i32),
    ElemThenNotEmpty(i32, Box&lt;List&gt;),
}
</code></pre>
<p>希望这在你看来是一个更糟糕的想法。最值得注意的是，这真的让我们的逻辑复杂化了，因为
现在有一个完全无效的状态：<code>ElemThenNotEmpty(0, Box(Empty))</code>。它也<em>仍然</em>受到非
统一分配我们元素的影响。</p>
<p>然而它有<em>一个</em>有趣的特性：它完全避免了分配为空的情况，使堆分配的总数减少了1，不幸
的是，在这样做的时候，它设法浪费了<em>更多的空间</em>！这是因为之前的布局利用了<em>空指针优
化</em>。</p>
<p>我们之前看到，每个枚举都必须存储一个标签，以指定其位代表枚举的哪个变体。然而，如果
我们有一种特殊的枚举：</p>
<pre><code class="language-rust ignore">enum Foo {
    A,
    B(ContainsANonNullPtr),
}
</code></pre>
<p>空指针优化来了，从而<em>消除了标签所需的空间</em>。如果变体是A，则整个枚举都设置为全0，否则
就是B。这样做的原因是B永远不会是所有的0，因为它包含一个非零指针。聪明!</p>
<p>你能想到其他的枚举和类型可以做到这样的优化吗？其实有很多! 这就是为什么Rust对枚举布局
完全不作规定。有一些更复杂的枚举布局优化，Rust会为我们做，但空指针这个绝对是最重要的!
这意味着<code>&amp;</code>、<code>&amp;mut</code>、<code>Box</code>、<code>Rc</code>、<code>Arc</code>、<code>Vec</code>以及Rust中其他几个重要的类型在放入
<code>Option</code>时没有任何开销! (我们会在适当的时候讲到其中的大部分)。</p>
<p>那么，我们如何避免额外的垃圾，统一分配，<em>并</em>获得甜蜜的空指针优化呢？我们需要更好地将拥
有一个元素的想法与分配另一个列表分开。要做到这一点，我们必须想得更像C语言：结构体!</p>
<p>枚举让我们声明一个可以包含多个值中的<em>一个</em>类型，而结构体让我们声明一个同时包含<em>许多</em>值
的类型。让我们把链表分成两种类型。一个链表和一个节点。</p>
<p>和之前一样，一个链表要么是空的，要么是有一个元素跟在另一个链表后面。通过用一个完全独立
的类型来表示“有一个被另一个链表跟随的元素”的情况，我们可以将盒子提升到一个更理想的位置：</p>
<pre><code class="language-rust ignore">struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>我们来确认优先级：</p>
<ul>
<li>列表尾部永远不会分配额外的垃圾：检查!</li>
<li><code>enum</code>是美味的空指针优化形式：检查!</li>
<li>所有元素都是统一分配的：检查!</li>
</ul>
<p>好吧！实际上，我们刚刚构建的布局正是我们用来证明我们的第一个布局（正如官方
Rust文档所建议的那样）是有问题的。</p>
<pre><code class="language-text">&gt; cargo build

warning: private type `first::Node` in public interface (error E0446)
 --&gt; src/first.rs:8:10
  |
8 |     More(Box&lt;Node&gt;),
  |          ^^^^^^^^^
  |
  = note: #[warn(private_in_public)] on by default
  = warning: this was previously accepted by the compiler but
    is being phased out; it will become a hard error in a future release!
</code></pre>
<p>:(</p>
<p>Rust又对我们发火了。我们把<code>List</code>标记为公共的（因为我们希望人们能够使用它），但<code>Node</code>
没有。问题是枚举的内部是完全公开的，我们不允许公开谈论私有类型。我们可以将<code>Node</code>的所
有内容完全公开，但一般来说，在Rust中，我们倾向于保持实现细节的私有性。让我们把<code>List</code>
做成一个结构体，这样我们就可以隐藏实现细节：</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
</code></pre>
<p>因为<code>List</code>是一个只有一个字段的结构体，所以它的大小与该字段相同。耶，零成本抽象!</p>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/first.rs:2:5
  |
2 |     head: Link,
  |     ^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: variant is never constructed: `Empty`
 --&gt; src/first.rs:6:5
  |
6 |     Empty,
  |     ^^^^^

warning: variant is never constructed: `More`
 --&gt; src/first.rs:7:5
  |
7 |     More(Box&lt;Node&gt;),
  |     ^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/first.rs:11:5
   |
11 |     elem: i32,
   |     ^^^^^^^^^

warning: field is never used: `next`
  --&gt; src/first.rs:12:5
   |
12 |     next: Link,
   |     ^^^^^^^^^^

</code></pre>
<p>好了，这下编译好了！Rust很生气，因为据它所知，我们写的所有东西都是完全无用的：我们从
来没有用过<code>head</code>，使用我们库的人也不能用，因为它是私有的。反过来说，这意味着<code>Link</code>和
<code>Node</code>也是无用的。所以我们来解决这个问题吧! 让我们为我们的List实现一些代码吧!</p>
<h1><a class="header" href="#新建" id="新建">新建</a></h1>
<p>我们使用了<code>impl</code>块，将实际的代码与类型联系起来：</p>
<pre><code class="language-rust ignore">impl List {
    // TODO, make code happen
}
</code></pre>
<p>现在我们只需要弄清楚如何实际编写代码。在Rust中，我们这么声明一个函数：</p>
<pre><code class="language-rust ignore">fn foo(arg1: Type1, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>我们首先需要的是一种<em>构造</em>列表的方式。由于我们隐藏了实现细节，我们需要以函数的形
式来提供。在Rust中，通常的方法是提供一个静态方法，也就是在<code>impl</code>中提供一个普通的
函数：</p>
<pre><code class="language-rust ignore">impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
</code></pre>
<p>有几点说明：</p>
<ul>
<li>Self是“我写在最上面的那个在<code>impl</code>旁边的类型”的别名。很好的避免了自己的重复。</li>
<li>我们创建一个结构体的实例的方式与我们声明它的方式很相似，只是我们没有提供它的字
段类型，而是用值来初始化它们</li>
<li>我们使用<code>::</code>来引用一个枚举的变体，这是命名间隔操作符。</li>
<li>一个函数的最后一个表达式是隐式返回的。这使得简单的函数变得更加整洁。你仍然可以
像其他类C语言一样，使用return来提前返回。</li>
</ul>
<h1><a class="header" href="#所有权101" id="所有权101">所有权101</a></h1>
<p>现在我们可以构造一个列表，如果能用它<code>做</code>一些事情就更好了。我们用“普通”(非静态)方
法来做这些事情。在Rust中，方法是函数的一种特殊情况，因为<code>self</code>参数没有声明类型：</p>
<pre><code class="language-rust ignore">fn foo(self, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>self可以有3种主要形式：<code>self</code>、<code>&amp;mut self</code>和<code>&amp;self</code>。这3种形式代表了Rust中所有权
的三种主要形式：</p>
<ul>
<li><code>self</code> - 值</li>
<li><code>&amp;mut self</code> - 可变引用</li>
<li><code>&amp;self</code> - 共享引用</li>
</ul>
<p>一个值代表了<em>真正</em>的所有权。你可以对一个值做任何你想做的事情：移动它，销毁它，改变
它，或者通过引用把它借出去。当你用值传递某物时，它就会被<em>移动</em>到新的位置。新的位置
现在拥有这个值，而旧的位置不能再访问它。出于这个原因，大多数方法都不想要<code>self</code>--如
果试图与一个链表一起工作，让它消失，那将是非常蹩脚的!</p>
<p>一个可变引用代表了对一个你不拥有的值的临时<em>独占访问</em>。你可以对一个有可变引用的值做
任何你想做的事情，只要你做完后让它处于有效状态（否则会对所有者不礼貌！）。这意味着
你实际上可以完全覆盖这个值。一个非常有用的特殊情况是将一个值<em>交换</em>另一个值，我们会
经常使用。你唯一不能用<code>&amp;mut</code>做的事情就是把值移出，而不进行替换。对于想要改变<code>self</code>
的方法来说，<code>&amp;mut self</code>是很好的选择。</p>
<p>共享引用代表了对一个你不拥有的值的临时<em>共享访问</em>。因为你有共享访问权，所以一般不允许
你改变任何东西。把<code>&amp;</code>想象成把值放在博物馆里展示。<code>&amp;</code>对于那些只想观察<code>self</code>的方法来
说，是非常好的。</p>
<p>后面我们会看到，在某些情况下，关于改变的规则是可以绕过的。这就是为什么共享引用不叫
<em>不可变引用</em>的原因。真的，可改变的引用可以被称为<em>唯一</em>引用，但我们发现，将所有权与
可改变性联系起来，99%的时候都能给出正确的直觉。</p>
<h1><a class="header" href="#推入" id="推入">推入</a></h1>
<p><code>push</code>会使链表发生<em>改变</em>，所以我们需要使用<code>&amp;mut self</code>。我们还需要取一个i32
来推入：</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
</code></pre>
<p>首先，我们需要做一个节点来存储我们的元素：</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: ?????
        };
    }
</code></pre>
<p><code>next</code>是什么？嗯，整个旧链表！我们能不能... ... 就这么做？</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head,
        };
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:19:19
   |
19 |             next: self.head,
   |                   ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>不——。Rust正告诉我们正确的事情，但它到底是什么意思，或者对它该怎么做，肯定不太显然：</p>
<blockquote>
<p>不能移出借用的上下文</p>
</blockquote>
<p>我们想把<code>self.head</code>字段移到<code>next</code>，但Rust不希望我们这么做。这将使<code>self</code>在我们结束
借用并将其“还给”它的合法所有者时，只被部分初始化。正如我们之前说过的，这是你不能用
<code>&amp;mut</code>做的<em>一件</em>事：这将是超级无礼的，而Rust是非常有礼貌的（这也将是难以置信的危险
，但<em>这</em>肯定不是它关心的原因）。</p>
<p>如果我们把东西放回去呢？也就是我们正在创建的节点：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:19:19
   |
19 |             next: self.head,
   |                   ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>没办法。原则上，这是Rust可以接受的，但它不会接受（出于各种原因--最严重的是<a href="https://doc.rust-lang.org/nightly/nomicon/exception-safety.html">例外安全</a>）
。我们需要一些方法在Rust没有注意到它消失的情况下得到头。为了寻求建议，我们求助于臭名昭著
的Rust黑客Indiana Jones：</p>
<p><img src="img/indy.gif" alt="Indy Prepares to mem::replace" /></p>
<p>啊，对了，Indy建议使用<code>mem::replace</code>手法。这个非常有用的函数可以让我们通过用另一个值<em>替
换</em>来从一个借用中偷取出来一个值。让我们在文件的顶部拉入<code>std::mem</code>，这样<code>mem</code>就在本地作
用域内：</p>
<pre><code class="language-rust ignore">use std::mem;
</code></pre>
<p>并适当地使用它：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: mem::replace(&amp;mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}
</code></pre>
<p>在这里，我们用Link::Empty暂时<code>replace</code>到self.head，然后再把self.head换成列表的新头。
我不会撒谎：这是一件非常不幸的事情。很遗憾，我们必须这么做（目前）。</p>
<p>但是，嘿，<code>push</code>全部完成! 可能吧。我们也许应该测试一下，说实话。现在，最简单的方法
可能是写<code>pop</code>，并确保它产生正确的结果。</p>
<h1><a class="header" href="#弹出" id="弹出">弹出</a></h1>
<p>和<code>push</code>一样，<code>pop</code>想要改变列表。与<code>push</code>不同的是，我们实际上想返回一些东西。
但<code>pop</code>还需要处理一个棘手的角落情况：如果链表是空的怎么办？为了表示这种情况，
我们使用可靠的<code>Option</code>类型：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    // TODO
}
</code></pre>
<p><code>Option&lt;T&gt;</code>是一个枚举，表示一个可能存在的值。它可以是<code>Some(T)</code>，也可以是<code>None</code>。
我们可以像对待Link一样，自己做一个枚举，但是我们希望我们的用户能够理解我们的返回类
型到底是什么，Option是如此的无处不在，以至于<em>每个人</em>都知道它。事实上，它是如此的基
本，以至于在每个文件中都会隐式地导入到scope中，还有它的变体<code>Some</code>和<code>None</code>（所以我
们不必说<code>Option::None</code>）。</p>
<p><code>Option&lt;T&gt;</code>上的尖头表示Option实际上是在T上<code>通用</code>的，这意味着你可以为<code>任何</code>类型制
作一个Option!</p>
<p>那么，呃，我们有这个<code>Link</code>的东西，我们怎么知道它是空的还是有More的？模式匹配与
<code>match</code>!</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/first.rs:27:30
   |
27 |     pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
   |            ---               ^^^^^^^^^^^ expected enum `std::option::Option`, found ()
   |            |
   |            this function's body doesn't return
   |
   = note: expected type `std::option::Option&lt;i32&gt;`
              found type `()`
</code></pre>
<p>糟糕，<code>pop</code>必须返回一个值，而我们还没有这样做。我们<em>其实可以</em>返回<code>None</code>，但在这种
情况下，返回<code>unimplemented!()</code>可能是一个更好的主意，以表明我们还没有完成函数的实
现。<code>unimplemented!()</code>是一个宏(<code>!</code>表示一个宏)，当我们到达它时，它会使程序惊慌失
措(~以一种可控的方式使它崩溃)。</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<p>无条件恐慌是<a href="https://doc.rust-lang.org/nightly/book/ch19-04-advanced-types.html#the-never-type-that-never-returns">发散函数</a>的一个例子。发散函数永远不会返回给调用者，所以它
们可以用在期待任何类型的值的地方。这里，<code>unimplemented!()</code>被用来代替一个
<code>Option&lt;T&gt;</code>类型的值。</p>
<p>还要注意，我们的程序中不需要写<code>return</code>。一个函数中的最后一个表达式（基本上是行）隐
含了它的返回值。这让我们可以更简洁地表达真正简单的东西。你总是可以像其他类C语言一
样，显式地用<code>return</code>提前返回。</p>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&amp;self.head`
...
32 |             Link::More(node) =&gt; {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box&lt;first::Node&gt;`, which does not implement the `Copy` trait
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^
</code></pre>
<p>来吧Rust，别烦我们了。一如既往，Rust对我们很生气。值得庆幸的是，这次它也给了我们完
整的信息! 默认情况下，模式匹配会尝试将其内容移动到新的分支中，但我们不能这样做，因
为我们在这里没有拥有self的值。</p>
<pre><code class="language-text">help: consider borrowing here: `&amp;self.head`
</code></pre>
<p>Rust说我们应该在<code>match</code>中添加一个引用来解决这个问题。🤷♀️让我们试试吧：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match &amp;self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(ref node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: unused variable: `node`
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^ help: consider prefixing with an underscore: `_node`
   |
   = note: #[warn(unused_variables)] on by default

warning: field is never used: `elem`
  --&gt; src/first.rs:13:5
   |
13 |     elem: i32,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/first.rs:14:5
   |
14 |     next: Link,
   |     ^^^^^^^^^^
</code></pre>
<p>万岁，又能编译了! 现在让我们弄清楚这个逻辑。我们想做一个Option，所以让我们为它做一
个变量。在Empty的情况下，我们需要返回None。在More的情况下，我们需要返回<code>Some(i32)</code>
，并改变列表的头。那么，让我们试着基本做到这一点？</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match &amp;self.head {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(ref node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:35:29
   |
35 |                 self.head = node.next;
   |                             ^^^^^^^^^ cannot move out of borrowed content

</code></pre>
<p><em>脑袋</em></p>
<p><em>办公桌</em></p>
<p>当我们只有一个共享引用的时候，我们正试图移出<code>node</code>。</p>
<p>我们也许应该退一步，想想我们要做什么。我们想：</p>
<ul>
<li>检查列表是否为空。</li>
<li>如果是空的，就返回None</li>
<li>如果它<em>不是</em>空的
<ul>
<li>移除链表的头</li>
<li>移除它的<code>elem</code></li>
<li>用它的<code>next</code>代替列表的头</li>
<li>返回<code>Some(elem)</code></li>
</ul>
</li>
</ul>
<p>关键的见解是我们要<em>删除</em>事物，这意味着我们要<em>通过值</em>来获得列表的头部。我们当然不能通过我们通过
<code>&amp;self.head</code>得到的共享引用来做到这一点。我们也&quot;只&quot;有一个对<code>self</code>的可变引用，所以我们移动东西
的唯一方法就是<em>替换它</em>。看来我们又在跳Empty舞了！</p>
<p>让我们试试吧：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>O M G</p>
<p>它在编译时没有<em>任何</em>警告!!!!!</p>
<p>其实我在这里要套用一下我个人的套路：我们把这个<code>result</code>做成了返回，但其实我们根本
不需要这么做！就像一个函数运算结果是它的最后一个表达式一样，每个块的运算结果也是
它的最后一个表达式。通常我们会用分号阻止这种行为，这样反而会使块评估为空元组，
<code>（）</code>。这实际上是不声明返回值的函数--比如<code>push</code>--返回的值。</p>
<p>因此，我们可以将<code>pop</code>写成：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; None,
        Link::More(node) =&gt; {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
</code></pre>
<p>这更简洁、更惯用。请注意，Link::Empty分支完全失去了括号，因为我们只有一个表达式
需要运算。只是一个很好的简写，用于简单的情况。</p>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>好，仍能运行！</p>
<h1><a class="header" href="#测试" id="测试">测试</a></h1>
<p>好了，我们已经写好了<code>推入</code>和<code>弹出</code>，现在我们可以真正测试出我们的堆栈了!Rust和cargo
支持测试作为一级功能，所以这将是超级简单的。我们要做的就是写一个函数，然后用
<code>#[test]</code>来注释它。</p>
<p>一般来说，在Rust社区中，我们尽量把测试放在它测试的代码旁边。然而我们通常会为测试做
一个新的命名空间，以避免与&quot;真正的&quot;代码冲突。就像我们使用<code>mod</code>来指定<code>first.rs</code>应该
包含在<code>lib.rs</code>中一样，我们可以使用<code>mod</code>来简单得创建一个全新的<em>内联</em>文件。</p>
<pre><code class="language-rust ignore">// in first.rs

mod test {
    #[test]
    fn basics() {
        // TODO
    }
}
</code></pre>
<p>我们用<code>cargo test</code>调用它。</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.00s
     Running /Users/ABeingessner/dev/lists/target/debug/deps/lists-86544f1d97438f1f

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
; 0 filtered out
</code></pre>
<p>耶，我们的什么都没做的测试通过了! 让我们把它变得做一些事情。我们将通过<code>assert_eq!</code>
宏来实现。这不是什么特殊的测试魔法。它所做的就是比较你给它的两个东西，如果它们不匹配
，程序就会惊慌失措。是的，你通过惊慌失措向测试套装表示失败!</p>
<pre><code class="language-rust ignore">mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0433]: failed to resolve: use of undeclared type or module `List`
  --&gt; src/first.rs:43:24
   |
43 |         let mut list = List::new();
   |                        ^^^^ use of undeclared type or module `List`


</code></pre>
<p>糟糕！因为我们做了一个新的模块，所以我们需要明确地拉入List来使用。因为我们做了一个
新的模块，所以我们需要显式拉入List来使用。</p>
<pre><code class="language-rust ignore">mod test {
    use super::List;
    // everything else the same
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

warning: unused import: `super::List`
  --&gt; src/first.rs:45:9
   |
45 |     use super::List;
   |         ^^^^^^^^^^^
   |
   = note: #[warn(unused_imports)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running /Users/ABeingessner/dev/lists/target/debug/deps/lists-86544f1d97438f1f

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
; 0 filtered out
</code></pre>
<p>呀！</p>
<p>不过那个警告是怎么回事...? 我们在测试中明明用的是List!</p>
<p>...但只在测试时使用! 为了安抚编译器(并对我们的消费者友好)，我们应该说明整个测试模块只有
在运行测试时才应该被编译。</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    // everything else the same
}
</code></pre>
<p>这就是测试的一切!</p>
<h1><a class="header" href="#丢弃" id="丢弃">丢弃</a></h1>
<p>我们可以做一个堆栈，推入，弹出，我们甚至已经测试过，这一切都正确！</p>
<p>我们需要担心清理我们的列表吗？从技术上讲，不，完全不需要！Rust和C++一样，使用
destructors来自动清理列表。像C++一样，Rust使用析构器来自动清理资源。如果一个
类型实现了一个叫做Drop的<em>特质</em>，它就有一个析构器。特质是Rust对接口的花哨称呼。
Drop特质有以下接口：</p>
<pre><code class="language-rust ignore">pub trait Drop {
    fn drop(&amp;mut self);
}
</code></pre>
<p>基本上，&quot;当你离开作用域时，我会给你一点时间来清理你的事务&quot;。</p>
<p>如果你包含了实现Drop的类型，你其实并不需要实现Drop，你要做的只是调用<em>它们</em>的析构函
数。在List的情况下，它所要做的就是丢弃它的头部，而头部又<em>可能</em>会尝试丢弃一个
<code>Box&lt;Node&gt;</code>。所有这些都会自动为我们处理......但有一个问题。</p>
<p>自动处理的效果会很差。</p>
<p>让我们考虑一个简单的列表：</p>
<pre><code class="language-text">list -&gt; A -&gt; B -&gt; C
</code></pre>
<p>当<code>list</code>被丢弃时，它会尝试丢弃A，会尝试丢弃B，会尝试丢弃C，你们中的一些人可能会正确
地开始紧张。这是递归代码，而递归代码会炸掉堆栈!</p>
<p>你们中的一些人可能会想：&quot;这显然是尾部递归，任何体面的语言都会确保这种代码不会炸堆&quot;。
事实上，这是不正确的! 为了了解原因，让我们试着写出编译器要做的事情，为我们的List手动
实现Drop，就像编译器一样：</p>
<pre><code class="language-rust ignore">impl Drop for List {
    fn drop(&amp;mut self) {
        // NOTE: you can't actually explicitly call `drop` in real Rust code;
        // we're pretending to be the compiler!
        self.head.drop(); // tail recursive - good!
    }
}

impl Drop for Link {
    fn drop(&amp;mut self) {
        match *self {
            Link::Empty =&gt; {} // Done!
            Link::More(ref mut boxed_node) =&gt; {
                boxed_node.drop(); // tail recursive - good!
            }
        }
    }
}

impl Drop for Box&lt;Node&gt; {
    fn drop(&amp;mut self) {
        self.ptr.drop(); // uh oh, not tail recursive!
        deallocate(self.ptr);
    }
}

impl Drop for Node {
    fn drop(&amp;mut self) {
        self.next.drop();
    }
}
</code></pre>
<p>我们<em>不能</em>在回收内存<em>之后</em>丢弃Box的内容，所以没有办法以尾部递归的方式丢弃！而我们要
手动为<code>List</code>写一个迭代丢弃，将节点从它们的盒子里吊出来。</p>
<pre><code class="language-rust ignore">impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);
        // `while let` == &quot;do this thing until this pattern doesn't match&quot;
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
            // boxed_node goes out of scope and gets dropped here;
            // but its Node's `next` field has been set to Link::Empty
            // so no unbounded recursion occurs.
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>棒！</p>
<hr />
<p><span style="float:left"><img src="img/profbee.gif" alt="Bonus" /></span></p>
<h2><a class="header" href="#提前优化的奖励部分" id="提前优化的奖励部分">提前优化的奖励部分！</a></h2>
<p>我们对drop的实现其实和<code>while let Some(_) = self.pop() { }</code><em>很</em>相似，当然更简单。
它有什么不同，一旦我们开始泛化我们的列表来存储整数以外的东西，会导致什么性能问题？</p>
<details>
  <summary>Click to expand for answer</summary>
<p>Pop返回<code>Option&lt;i32&gt;</code>，而我们的实现只操作Links（<code>Box&lt;Node&gt;</code>）。所以我们的实现只移动节点的指针，而基于pop的实现将移动我们存储在节点中的值。如果我们通用我们的列表，有人用它来存储很大的有丢弃实现的东西(VBTWADI)的实例，这可能会非常昂贵。Box能够在原地运行其内容的drop实现，所以它不会受到这个问题的影响。由于VBTWADI正是实际上使用linked-list比使用数组更可取，所以在这种情况下表现不佳会让人有点失望。</p>
<p>如果你希望同时拥有两种实现的优点，你可以添加一个新的方法，<code>fn pop_node(&amp;mut self) -&gt; Link</code>，<code>pop</code>和<code>drop</code>都可以干净利落地从它派生出来。</p>
</details>
<h1><a class="header" href="#the-final-code" id="the-final-code">The Final Code</a></h1>
<p>好吧，6000字后，这里是我们设法写下的所有代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; None,
            Link::More(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);

        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
#}</code></pre></pre>
<p>天啊，80行，一半是测试！80行，其中一半是测试! 好吧，我说过这第一篇要花点时间的!</p>
<h1><a class="header" href="#一个好的单链栈" id="一个好的单链栈">一个好的单链栈</a></h1>
<p>在上一章中，我们写了一个最小可行的单链栈。然而，有几个设计决定使它变得有点糟
糕。让我们把它变得不那么糟糕。在这样做的时候，我们将：</p>
<ul>
<li>取消发明轮子</li>
<li>使我们的列表能够处理任何元素类型</li>
<li>增加选择功能</li>
<li>使我们的列表可迭代</li>
</ul>
<p>在这个过程中，我们将了解到</p>
<ul>
<li>高级选项的使用</li>
<li>泛型</li>
<li>生命期</li>
<li>迭代器</li>
</ul>
<p>让我们添加一个名为<code>second.rs</code>的新文件：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
</code></pre>
<p>并将<code>first.rs</code>中的所有内容复制到其中。</p>
<h1><a class="header" href="#使用option" id="使用option">使用Option</a></h1>
<p>细心的读者可能已经注意到，我们实际上重新发明了一个非常糟糕的Option版本：</p>
<pre><code class="language-rust ignore">enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>Link只是<code>Option&lt;Box&lt;Node&gt;&gt;</code>。现在，可以不用到处写<code>Option&lt;Box&lt;Node&gt;&gt;</code>了，
真不错。而且与<code>pop</code>不同的是，我们并没有把它暴露给外部世界，所以也许这很好。
然而Option有一些<em>非常好</em>的方法，我们一直在手动实现。我们<em>不要</em>这样做，用
Options代替一切。首先，我们要做的是简单地使用Some和None重命名所有的东西：</p>
<pre><code class="language-rust ignore">use std::mem;

pub struct List {
    head: Link,
}

// yay type aliases!
type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, None),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, None) {
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, None);
        while let Some(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, None);
        }
    }
}
</code></pre>
<p>这稍微好一点，但最大的胜利来自于 Option 的方法。</p>
<p>首先，<code>mem::replace(&amp;mut option, None)</code>是一个非常常见的习语，Option实际上只是把它
作为一个方法：<code>take</code>。</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match self.head.take() {
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>第二，<code>match option { None =&gt; None, Some(x) =&gt; Some(y) }</code>是一个非常惯用的写法，
以至于它被称为<code>map</code>。<code>map</code>需要一个函数来对<code>Some(x)</code>中的<code>x</code>执行，以产生<code>Some(y)</code>
中的<code>y</code>。我们可以写一个适当的<code>fn</code>并把它传递给<code>map</code>，但我们更愿意写出<em>内联</em>要做什
么。</p>
<p>做到这一点的方法是使用一个<em>闭包</em>。闭包是匿名函数，有一个额外的超级能力：它们可以
引用闭包<em>之外</em>的局部变量。这使得它们在做各种条件逻辑时超级有用。我们唯一进行
<code>match</code>的地方是在<code>pop</code>中，所以让我们重写一下：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    self.head.take().map(|node| {
        self.head = node.next;
        node.elem
    })
}
</code></pre>
<p>啊，好多了。让我们确保我们没有打破任何东西：</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>很好! 让我们继续实际改进代码的<em>行为</em>。</p>
<h1><a class="header" href="#让他全变成泛型" id="让他全变成泛型">让他全变成泛型</a></h1>
<p>我们已经用 Option 和 Box 触及了一些泛型。然而到目前为止，我们一直设法避免声明任
何新的类型，这些类型实际上是对任意元素的泛型。</p>
<p>事实证明，这其实很容易。让我们现在就把我们所有的类型都变成泛型：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>你只要把所有的东西都变得更尖角一点，突然间你的代码就会变得很通用。当然，我们不
能<em>就</em>这样做，否则编译器就会变得超级疯狂。</p>
<pre><code class="language-text">&gt; cargo test

error[E0107]: wrong number of type arguments: expected 1, found 0
  --&gt; src/second.rs:14:6
   |
14 | impl List {
   |      ^^^^ expected 1 type argument

error[E0107]: wrong number of type arguments: expected 1, found 0
  --&gt; src/second.rs:36:15
   |
36 | impl Drop for List {
   |               ^^^^ expected 1 type argument

</code></pre>
<p>问题很明显：我们在谈论这个<code>List</code>的事情，但那已经不是真的了。像 Option 和 Box 一样，
我们现在总是要谈论 <code>List&lt;Something&gt;</code>。</p>
<p>但是我们在所有这些暗示中使用的Something是什么？就像List一样，我们希望我们的实现能与
<em>所有</em>的T一起工作。所以，就像List一样，让我们的<code>impls</code>变得尖尖的：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>......就这样了!</p>
<pre><code>&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>我们所有的代码现在在任意的T值上都是完全通用的，铛，Rust很<em>容易</em>。我想对甚至没有改
变的<code>new</code>做一个特别的叫喊：</p>
<pre><code class="language-rust ignore">pub fn new() -&gt; Self {
    List { head: None }
}
</code></pre>
<p>沐浴在Self的光辉中，它是重构和复制粘贴编码的守护者。同样有趣的是，当我们构造一个
链表的实例时，我们并没有写 <code>List&lt;T&gt;</code>。这一部分是根据我们从一个期望有 <code>List&lt;T&gt;</code>
的函数中返回的事实来推断的。</p>
<p>好了，让我们继续讨论全新的<em>行为</em>吧！</p>
<h1><a class="header" href="#选择" id="选择">选择</a></h1>
<p>有一件事我们上次甚至懒得实施，就是选择。让我们继续做这个。我们所要做的就是返回一
个对列表头部元素的引用，如果它存在的话。听起来很简单，让我们试试吧：</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0515]: cannot return reference to local data `node.elem`
  --&gt; src/second.rs:37:13
   |
37 |             &amp;node.elem
   |             ^^^^^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:36:9
   |
36 |         self.head.map(|node| {
   |         ^^^^^^^^^ cannot move out of borrowed content


</code></pre>
<p><em>叹息</em>。现在怎么办，Rust？</p>
<p>地图通过值来获取<code>self</code>，这将会把Option移出它所在的地方。以前这很好，因为我们只是把它
取出来，但是现在我们实际上想把它留在原处。处理这个问题的<em>正确</em>方法是使用Option的
<code>as_ref</code>方法，它的定义如下：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;
}
</code></pre>
<p>它将 Option<T> 降级为对其内部的引用的 Option。我们可以通过显式匹配来实现这一点，但
是<em>不行</em>。这确实意味着我们需要做一个额外的析构来切断额外的指示，但幸运的是<code>.</code>操作符
为我们处理了这个问题。</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build

    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
</code></pre>
<p>钉住了。</p>
<p>我们也可以用<code>as_mut</code>制作这个方法的<em>可变</em>版本：</p>
<pre><code class="language-rust ignore">pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    self.head.as_mut().map(|node| {
        &amp;mut node.elem
    })
}
</code></pre>
<pre><code class="language-text">lists::cargo build

</code></pre>
<p>EZ</p>
<p>别忘了测试一下：</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>这很好，但我们并没有真正测试是否可以改变那个<code>peek_mut</code>的返回值，不是吗？如果一个引
用是可变的，但是没有人改变它，我们真的测试了可变性吗？让我们试试在这个
<code>Option&lt;&amp;mut T&gt;</code>上使用<code>map</code>，放一个奥妙的值：</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
    list.peek_mut().map(|&amp;mut value| {
        value = 42
    });

    assert_eq!(list.peek(), Some(&amp;42));
    assert_eq!(list.pop(), Some(42));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0384]: cannot assign twice to immutable variable `value`
   --&gt; src/second.rs:100:13
    |
99  |         list.peek_mut().map(|&amp;mut value| {
    |                                   -----
    |                                   |
    |                                   first assignment to `value`
    |                                   help: make this binding mutable: `mut value`
100 |             value = 42
    |             ^^^^^^^^^^ cannot assign twice to immutable variable          ^~~~~
</code></pre>
<p>编译器抱怨说<code>value</code>是不可变的，但我们很清楚地写了<code>&amp;mut value</code>；这又是怎么回事呢？事
实证明，这样写闭包的参数并没有说明<code>value</code>是一个可变的引用。相反，它创建了一个将与闭
包的参数相匹配的模式；<code>|&amp;mut value|</code>意味着 &quot;参数是一个可变的引用，但是请将它指向的值
复制到<code>value</code>中&quot;。如果我们只使用<code>|value|</code>，<code>value</code>的类型将是<code>&amp;mut i32</code>，我们就可以
真正地对头部进行改变：</p>
<pre><code class="language-rust ignore">    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>好多了！</p>
<h1><a class="header" href="#进入遍历" id="进入遍历">进入遍历</a></h1>
<p>在Rust中使用<em>Iterator</em>特性对集合进行迭代。这比<code>Drop</code>要复杂一点：</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>块里的新东西是<code>type Item</code>。这宣告了每个迭代器的实现都有一个<em>相关的类型</em>，叫做Item。
在这种情况下，当你调用<code>next</code>时，它可以吐出这个类型。</p>
<p>Iterator产生<code>Option&lt;Self::Item&gt;</code>的原因是该接口集成了<code>has_next</code>和<code>get_next</code>的概念。
当你有下一个值时，你产生<code>Some(value)</code>，而当你没有时，你产生<code>None</code>。这使得API在使用
和实现上更加符合人体工程学和安全，同时避免了<code>has_next</code>和<code>get_next</code>之间多余的检查和
逻辑。很好!</p>
<p>遗憾的是，Rust（现在还）没有类似<code>yield</code>语句的东西，所以我们必须自己实现这个逻辑。另
外，每个集合应该努力实现3种不同的迭代器：</p>
<ul>
<li>IntoIter - <code>T</code></li>
<li>IterMut - <code>&amp;mut T</code></li>
<li>Iter - <code>&amp;T</code></li>
</ul>
<p>实际上，我们已经有了使用List接口实现IntoIter的所有工具：只需不断地调用<code>pop</code>。因此，
我们只需将IntoIter作为List的一个新类型包装器来实现：</p>
<pre><code class="language-rust ignore">// Tuple structs are an alternative form of struct,
// useful for trivial wrappers around other types.
pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}
</code></pre>
<p>然后让我们写一个测试：</p>
<pre><code class="language-rust ignore">#[test]
fn into_iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), None);
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 4 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>棒！</p>
<h1><a class="header" href="#遍历" id="遍历">遍历</a></h1>
<p>好吧，让我们试着实现Iter。这一次，我们将不能依靠List提供我们想要的所有功能。我
们需要推出我们自己的。我们想要的基本逻辑是持有一个指向当前节点的指针，我们想要
产生下一个节点。因为这个节点可能不存在（列表是空的或者我们已经完成了迭代），我
们希望这个引用是一个 Option。当我们产生一个元素时，我们希望继续到当前节点的下一
个节点。</p>
<p>好吧，我们来试试：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:72:18
   |
72 |     next: Option&lt;&amp;Node&lt;T&gt;&gt;,
   |                  ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:82:17
   |
82 |     type Item = &amp;T;
   |                 ^ expected lifetime parameter
</code></pre>
<p>哦，上帝。生命周期。我听说过这些事情。我听说它们是一场恶梦。</p>
<p>让我们试试新的东西：看到那个<code>error[E0106]</code>的东西吗？那是一个编译器错误代码。我们可
以让rustc用<code>--explain</code>来解释这些：</p>
<pre><code class="language-text">&gt; rustc --explain E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).

Here are some simple examples of where you'll run into this error:

struct Foo { x: &amp;bool }        // error
struct Foo&lt;'a&gt; { x: &amp;'a bool } // correct

enum Bar { A(u8), B(&amp;bool), }        // error
enum Bar&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr = &amp;str;        // error
type MyStr&lt;'a&gt; = &amp;'a str; //correct
...

</code></pre>
<p>这......这并没有真正说明什么（这些文档假设我们比现在更了解Rust）。但看起来我们应该把
这些<code>'a</code>添加到我们的结构中去？让我们试试吧。</p>
<pre><code>pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:83:22
   |
83 | impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
   |                      ^^^^^^^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:84:17
   |
84 |     type Item = &amp;T;
   |                 ^ expected lifetime parameter

error: aborting due to 2 previous errors
</code></pre>
<p>好吧，我开始看到一个模式......让我们把这些小家伙添加到我们能做的所有事情中：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; List&lt;T&gt; {
    pub fn iter(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;'a node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;'a mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;'a node);
            &amp;'a node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error: expected `:`, found `node`
  --&gt; src/second.rs:77:47
   |
77 |         Iter { next: self.head.map(|node| &amp;'a node) }
   |         ---- while parsing this struct        ^^^^ expected `:`

error: expected `:`, found `node`
  --&gt; src/second.rs:85:50
   |
85 |             self.next = node.next.map(|node| &amp;'a node);
   |                                                  ^^^^ expected `:`

error[E0063]: missing field `next` in initializer of `second::Iter&lt;'_, _&gt;`
  --&gt; src/second.rs:77:9
   |
77 |         Iter { next: self.head.map(|node| &amp;'a node) }
   |         ^^^^ missing `next`
</code></pre>
<p>哦，上帝。我们搞坏了Rust。</p>
<p>也许我们应该搞清楚这个<code>'a</code>生命周期到底是什么意思。</p>
<p>生命周期会吓跑很多人，因为它是对我们从编程之初就知道并喜爱的东西的改变。到目前为止
，我们实际上已经成功地避开了生命周期，尽管它们一直在我们的程序中纠缠不清。</p>
<p>生命周期在垃圾收集语言中是不必要的，因为垃圾收集器会确保所有的东西都能神奇地活到它
需要的时间。Rust中的大多数数据都是<em>人工</em>管理的，所以这些数据需要另一种解决方案。C
和C++给了我们一个清晰的例子，如果你只是让人们在堆栈上拿指针去随机数据会发生什么：
普遍的不可管理的不安全。这可以粗略地分为两类错误：</p>
<ul>
<li>持有一个超出范围的东西的指针</li>
<li>持有一个指向被改变的东西的指针</li>
</ul>
<p>生命周期可以解决这两个问题，而且99%的情况下，它们是以一种完全透明的方式进行的。</p>
<p>那么什么是生命周期呢？</p>
<p>很简单，生命周期是程序中某个区域（~块/范围）代码的名称。就是这样。当一个引用被标记
为生命周期时，我们是说它必须对<em>整个</em>区域有效。不同的东西对一个引用必须和可以在多长时
间内有效提出了要求。整个生命周期系统又只是一个约束解决系统，它试图最小化每个引用的区
域。如果它成功地找到了一组满足所有约束条件的生命周期，你的程序就可以编译了！否则你就
会得到一个错误反馈，说什么东西的生命周期不够长。</p>
<p>在一个函数体中，你一般不能谈论生命周期，而且也不想谈论。编译器有完整的信息，可以推断
出所有的限制条件来找到最小的生命周期。然而在类型和API层面，编译器<em>并没有</em>所有的信息。
它需要你告诉它不同生命周期之间的关系，这样它才能弄清楚你在做什么。</p>
<p>原则上说，这些生命周期也<em>可以</em>不写，但这样一来，检查所有的借用将是一个巨大的全程序分
析，会产生令人难以置信的非本地错误。Rust的系统意味着所有的借用检查都可以在每个函数体
中独立完成，你的所有错误都应该是相当局部的（或者你的类型有错误的签名）。</p>
<p>但是我们以前也在函数签名中写过引用，而且很好！为什么？这是因为有一些情况非常普遍，
Rust会自动为你挑选生命周期。这就是<em>寿命消除</em>。</p>
<p>特别地：</p>
<pre><code class="language-rust ignore">// Only one reference in input, so the output must be derived from that input
fn foo(&amp;A) -&gt; &amp;B; // sugar for:
fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;

// Many inputs, assume they're all independent
fn foo(&amp;A, &amp;B, &amp;C); // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a A, &amp;'b B, &amp;'c C);

// Methods, assume all output lifetimes are derived from `self`
fn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;
</code></pre>
<p>那么，<code>fn foo&lt;'a&gt;(&amp;'a A)-&gt;&amp;'a B</code>是什么<em>意思</em>？在实践中，它的意思是，输入必须至少与输
出一样长。因此，如果你把输出保留很长一段时间，这将扩大输入必须有效的区域。一旦你停止使
用输出，编译器就会知道输入也可以变得无效了。</p>
<p>有了这个系统的设置，Rust可以确保在free之后没有任何东西被使用，而且在未完成的引用存在时
没有任何东西被改变。它只是确保这些约束条件都能得到解决。</p>
<p>好的。那么。Iter。</p>
<p>让我们回到没有生命周期的状态：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>我们只需要在函数和类型签名中添加生命期：</p>
<pre><code class="language-rust ignore">// Iter is generic over *some* lifetime, it doesn't care
pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

// No lifetime here, List doesn't have any associated lifetimes
impl&lt;T&gt; List&lt;T&gt; {
    // We declare a fresh lifetime here for the *exact* borrow that
    // creates the iter. Now &amp;self needs to be valid as long as the
    // Iter is around.
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

// We *do* have a lifetime here, because Iter has one that we need to define
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    // Need it here too, this is a type declaration
    type Item = &amp;'a T;

    // None of this needs to change, handled by the above.
    // Self continues to be incredibly hype and amazing
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>好吧，我想这次我们得到了它，你们都。</p>
<pre><code class="language-text">cargo build

error[E0308]: mismatched types
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &amp;node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &amp;node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;'a second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`
</code></pre>
<p>(╯°□°)╯︵ ┻━┻</p>
<p>好的。所以。我们修复了我们的生命周期错误，但现在我们得到了一些新的类型错误。</p>
<p>我们想存储<code>&amp;Node</code>的，但我们得到的是<code>&amp;Box&lt;Node&gt;</code>的。好吧，这很容易，我们只需
要在引用之前取消对Box的引用：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;*node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0515]: cannot return reference to local data `*node`
  --&gt; src/second.rs:77:43
   |
77 |         Iter { next: self.head.map(|node| &amp;*node) }
   |                                           ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &amp;*node) }
   |                      ^^^^^^^^^ cannot move out of borrowed content

error[E0515]: cannot return reference to local data `*node`
  --&gt; src/second.rs:85:46
   |
85 |             self.next = node.next.map(|node| &amp;*node);
   |                                              ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &amp;*node);
   |                         ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>(ﾉಥ益ಥ）ﾉ﻿ ┻━┻</p>
<p>我们忘记了<code>as_ref</code>，所以我们要把盒子移到<code>map</code>里，这意味着它将被丢弃，这意味着我
们的引用将被悬空：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;*node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0308]: mismatched types
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.as_ref().map(|node| &amp;*node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.as_ref().map(|node| &amp;*node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;'a second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

</code></pre>
<p>😭</p>
<p><code>as_ref</code>又增加了一层我们需要去除的间接性：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build

</code></pre>
<p>🎉 🎉 🎉</p>
<p>as_deref和as-derf_mut函数在Rust 1.40中已经稳定。在此之前，你需要做<code>map(|node| &amp;**node)</code>
和<code>map(|node| &amp;mut**node)</code>。你可能会想&quot;哇，那个<code>&amp;**</code>的东西真的很古怪&quot;，你没有错，但就像美
酒一样，Rust会随着时间的推移变得更好，我们不再需要这样做。通常情况下，Rust非常善于隐式地进
行这种转换，通过一个叫做<em>deref coercion</em>的过程，基本上它可以在你的代码中插入*，使其进行类
型检查。它可以做到这一点，因为我们有借贷检查器来确保我们不会弄乱指针！</p>
<p>但是在这种情况下，闭合与我们有一个<code>Option&lt;&amp;T&gt;</code>而不是<code>&amp;T</code>的事实相结合，对它来说有点太复杂了，
所以我们需要通过明确的方式来帮助它。值得庆幸的是，根据我的经验，这种情况相当少见。</p>
<p>为了完整起见，我们<em>可以</em>用<em>Turbofish</em>给它一个<em>不同</em>的提示：</p>
<pre><code class="language-rust ignore">    self.next = node.next.as_ref().map::&lt;&amp;Node&lt;T&gt;, _&gt;(|node| &amp;node);
</code></pre>
<p>看，map是一个泛型函数：</p>
<pre><code class="language-rust ignore">pub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;
</code></pre>
<p>涡轮鱼，<code>:&lt;&gt;</code>，让我们告诉编译器我们认为这些泛型的类型应该是什么。在这个例子中
<code>::&lt;&amp;Node&lt;T&gt;, _&gt;</code>说 &quot;它应该返回一个<code>&amp;Node&lt;T&gt;</code>，而我不知道/不关心其他类型&quot;。</p>
<p>这反过来又让编译器知道<code>&amp;node</code>应该被应用于解引用强制转换，所以我们不需要手动应用所有这
些*!</p>
<p>但在这种情况下，我不认为这真的是一种改进，这只是一个薄薄的借口，来展示解引用强制转换和
有时有用的涡轮鱼。😅</p>
<p>让我们写一个测试，以确定我们没有拒绝它或任何东西：</p>
<pre><code class="language-rust ignore">#[test]
fn iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>赫赫有名。</p>
<p>最后，应该指出的是，我们实际上可以在这里应用生命周期消除：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}
</code></pre>
<p>等同于：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_deref() }
    }
}
</code></pre>
<p>更少的生命期!</p>
<p>或者，如果你不愿意&quot;隐藏&quot;一个结构包含一个生命周期，你可以使用Rust 2018的“
明确删除生命周期”语法，<code>'_</code>：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}
</code></pre>
<h1><a class="header" href="#可变遍历" id="可变遍历">可变遍历</a></h1>
<p>老实说，可变遍历是很疯狂的。这本身就像是一个疯狂的说法；它肯定与Iter相同！</p>
<p>从语义上讲，是的，但是共享和可变引用的本质意味着Iter是&quot;微不足道的&quot;，而
IterMut是合法的巫师魔法。</p>
<p>关键的洞察力来自于我们对Iter的Iterator的实现：</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { /* stuff */ }
}
</code></pre>
<p>这可以被解开语法糖为：</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Option&lt;&amp;'a T&gt; { /* stuff */ }
}
</code></pre>
<p><code>next</code>的签名在输入和输出的生命周期之间<em>没有</em>建立任何约束! 我们为什么要关心这
个？这意味着我们可以无条件地一次又一次地调用<code>next</code>!</p>
<pre><code class="language-rust ignore">let mut list = List::new();
list.push(1); list.push(2); list.push(3);

let mut iter = list.iter();
let x = iter.next().unwrap();
let y = iter.next().unwrap();
let z = iter.next().unwrap();
</code></pre>
<p>酷！</p>
<p>这对共享引用来说<em>绝对是好的</em>，因为整个要点是你可以同时拥有大量的引用。然而，易变的
引用<em>不能</em>共存。重点是它们是排他性的。</p>
<p>最终的结果是，使用安全的代码来编写IterMut是非常困难的（我们还没有深入了解这意味着
什么......）。令人惊讶的是，IterMut实际上可以完全安全地实现许多结构!</p>
<p>我们将从Iter的代码开始，把所有的东西都改成可变的：</p>
<pre><code class="language-rust ignore">pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter_mut(&amp;self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0596]: cannot borrow `self.head` as mutable, as it is behind a `&amp;` reference
  --&gt; src/second.rs:95:25
   |
94 |     pub fn iter_mut(&amp;self) -&gt; IterMut&lt;'_, T&gt; {
   |                     ----- help: consider changing this to be a mutable reference: `&amp;mut self`
95 |         IterMut { next: self.head.as_deref_mut() }
   |                         ^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error[E0507]: cannot move out of borrowed content
   --&gt; src/second.rs:103:9
    |
103 |         self.next.map(|node| {
    |         ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>好吧，看起来我们在这里有两个不同的错误。第一个错误看起来非常清楚，它甚至告诉我们如何解决它！你
不能把一个共享的引用升级为一个可变的引用，所以<code>iter_mut</code>需要把<code>&amp;mut self</code>。只是一个愚蠢的复制
粘贴错误。</p>
<pre><code class="language-rust ignore">pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
    IterMut { next: self.head.as_deref_mut() }
}
</code></pre>
<p>那另一个呢？</p>
<p>哎呀! 其实我在写上一节的<code>iter</code> impl时不小心犯了一个错误，我们只是在侥幸地认为它成
功了!</p>
<p>我们刚刚第一次接触到了Copy的魔力。当我们介绍<a href="first-ownership.html">所有权</a>时，我们说当你移动
东西时，你就不能再使用它了。对于某些类型，这是很有意义的。我们的好朋友Box为我们管理
着堆上的分配，我们当然不希望有两段代码认为它们需要释放它的内存。</p>
<p>然而，对于其他类型来说，这就是<em>垃圾</em>了。整数没有所有权语义；它们只是无意义的数字！
这就是为什么整数被标记为Copy。众所周知，Copy类型是完全可以通过比特拷贝的方式来复制
的。因此，它们有一个超级能力：当被移动时，旧的值仍然<em>可以</em>使用。因此，你甚至可以将
一个Copy类型从一个引用中移出而不需要替换</p>
<p>rust中所有的数字基元（i32, u64, bool, f32, char, etc...）都是Copy。你也可以声明任
何用户定义的类型是Copy，只要它的所有组件都是Copy。</p>
<p>最关键的是，共享引用也是Copy! 因为<code>&amp;</code>是Copy，<code>Option&lt;&amp;&gt;</code><em>也</em>是Copy。所以当我们做
<code>self.next.map</code>的时候就很好，因为Option只是被复制了。现在我们不能这样做了，因为
<code>&amp;mut</code>不是Copy（如果你复制了一个&amp;mut，你就会有两个&amp;mut到内存的同一个位置，这是禁止
的）。相反，我们应该正确地<code>take</code> Option来获得它。</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.next.take().map(|node| {
        self.next = node.next.as_deref_mut();
        &amp;mut node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>呃......哇。我的妈呀 IterMut跑起来了!</p>
<p>让我们测试一下这个：</p>
<pre><code class="language-rust ignore">#[test]
fn iter_mut() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter_mut();
    assert_eq!(iter.next(), Some(&amp;mut 3));
    assert_eq!(iter.next(), Some(&amp;mut 2));
    assert_eq!(iter.next(), Some(&amp;mut 1));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 6 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>是的。它是有效的。</p>
<p>真他妈的。</p>
<p>什么。</p>
<p>好吧，我的意思是它实际上<em>是</em>应该工作的，但通常会有一些愚蠢的东西挡住了它的去路! 让
我们在这里说清楚：</p>
<p>我们刚刚实现了一段代码，它接收了一个单链的列表，并且最多返回一次列表中每个元素的可变
引用。而且它是经过静态验证的，可以做到这一点。它是完全安全的。我们不需要做任何疯狂的
事情。</p>
<p>如果你问我，这是件大事。有几个原因可以说明这一点：</p>
<ul>
<li>我们<code>take</code> <code>Option&lt;&amp;mut&gt;</code>，所以我们可以独占地访问可变的引用。不需要担心有人会再看
它。</li>
<li>Rust知道把一个可变引用分散到指向的结构的子字段中是可以的，因为没有办法&quot;回到上面&quot;，
而且它们肯定是不相干的。</li>
</ul>
<p>事实证明，你也可以应用这个基本逻辑来为数组或树获得一个安全的IterMut！你甚至可以把迭代
器变成一个安全的迭代器。你甚至可以让迭代器变成DoubleEnded，这样你就可以同时从前面和后
面消耗迭代器了。呜呼!</p>
<h1><a class="header" href="#final-code" id="final-code">Final Code</a></h1>
<p>好了，第二份清单就到此为止；这是最后的代码！</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // access fields of a tuple struct numerically
        self.0.pop()
    }
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 1));
    }
}

#}</code></pre></pre>
<p>越来越强壮了!</p>
<h1><a class="header" href="#一个持久化的单链栈" id="一个持久化的单链栈">一个持久化的单链栈</a></h1>
<p>好了，我们已经掌握了可变单链堆栈的艺术。</p>
<p>让我们通过编写一个<em>持久化的</em>不可变的单链接列表，从<em>单一</em>所有权转向<em>共享</em>所有权。
这将是函数式程序员所熟悉和喜爱的列表。你可以得到头或尾，把别人的头放在别人的尾
上......而且......基本上就是这样了。不变性是一种地狱般的毒药。</p>
<p>在这个过程中，我们很大程度上只是熟悉了Rc和Arc，但这将为我们下一个<em>改变游戏</em>的清
单做准备。</p>
<p>让我们添加一个名为<code>third.rs</code>的新文件：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
</code></pre>
<p>这次没有复制--粘帖。这是一个净室操作。</p>
<h1><a class="header" href="#布局" id="布局">布局</a></h1>
<p>好了，回到布局的画板上。</p>
<p>持久列表最重要的一点是，你基本上可以没有成本地操作列表的尾部：</p>
<p>例如，在持久性列表中，这并不是一个不常见的工作量：</p>
<pre><code class="language-text">list1 = A -&gt; B -&gt; C -&gt; D
list2 = tail(list1) = B -&gt; C -&gt; D
list3 = push(list2, X) = X -&gt; B -&gt; C -&gt; D
</code></pre>
<p>但在最后，我们希望内存看起来像这样：</p>
<pre><code class="language-text">list1 -&gt; A ---+
              |
              v
list2 ------&gt; B -&gt; C -&gt; D
              ^
              |
list3 -&gt; X ---+
</code></pre>
<p>这对Boxes来说就是不行的，因为<code>B</code>的所有权是<em>共享</em>的。谁应该释放它？如果我放弃list2，
它会释放B吗？对于盒子，我们当然希望如此。</p>
<p>函数式语言--事实上几乎所有其他语言--都通过使用<em>垃圾回收</em>来解决这个问题。有了垃圾收集
的魔力，只有在每个人都不再看它的时候，B才会被释放。万幸！</p>
<p>Rust没有像这些语言那样的垃圾收集器。他们有<em>追踪</em>的GC，它将挖掘所有在运行时闲置的内
存，并自动找出哪些是垃圾。相反，Rust现在有的只是<em>引用计数</em>。引用计数可以被认为是一个
非常简单的GC。对于许多工作情况来说，它的吞吐量明显低于跟踪收集器，而且如果你设法建立
循环，它就会完全崩溃。但是，这就是我们所能得到的一切了。值得庆幸的是，对于我们的用例
来说，我们永远不会遇到周期问题（请随时尝试向自己证明这一点 -- 我肯定不会）。</p>
<p>那么，我们如何进行引用计数的垃圾收集呢？<code>Rc</code>! Rc就像Box一样，但我们可以复制它，而且
它的内存<em>只有</em>在<em>所有</em>从它派生出来的Rc被丢弃时才会被释放。不幸的是，这种灵活性有一个
严重的代价：我们只能对其内部进行共享引用。这意味着我们永远不能从我们的一个列表中获取
数据，也不能对它们进行变异。</p>
<p>那么，我们的布局会是什么样子的呢？嗯，之前我们有：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>我们能不能把Box改成Rc？</p>
<pre><code class="language-rust ignore">// in third.rs

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0412]: cannot find type `Rc` in this scope
 --&gt; src/third.rs:5:23
  |
5 | type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;
  |                       ^^ not found in this scope
help: possible candidate is found in another module, you can import it into scope
  |
1 | use std::rc::Rc;
  |
</code></pre>
<p>哦，该死，坏起来了。与我们用于可变列表的一切不同，Rc是如此蹩脚，以至于它甚至没有被
隐含地导入到每一个Rust程序中。<em>真是个失败者。</em></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `head`
 --&gt; src/third.rs:4:5
  |
4 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `elem`
  --&gt; src/third.rs:10:5
   |
10 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `next`
  --&gt; src/third.rs:11:5
   |
11 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>似乎是合法的。Rust的编写仍然是<em>完全</em>微不足道的。我打赌我们可以用Rc查找和替换Box，然后
就可以了。</p>
<p>...</p>
<p>不，不，我们不能。</p>
<h1><a class="header" href="#基本" id="基本">基本</a></h1>
<p>我们现在已经知道了很多Rust的基础知识，所以我们可以再次做很多简单的事情。</p>
<p>对于构造函数，我们又可以直接复制粘贴了：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }
}
</code></pre>
<p><code>push</code>和<code>pop</code>已经没有实际意义了。相反，我们可以提供<code>append</code>和<code>tail</code>，它们提供的东
西大致相同。</p>
<p>让我们从append开始。它接受一个列表和一个元素，并返回一个列表。就像可变列表的情况一样，
我们要做一个新的节点，它的<code>next</code>值是旧列表。唯一新奇的是如何获得下一个值，因为我们不
允许改变任何东西。</p>
<p>我们祈祷的答案就是Clone特性。几乎所有的类型都实现了克隆，它提供了一种通用的方法来获得
&quot;像这样的另一个&quot;，而这个逻辑上是不相干的，只给了一个共享的引用。它就像C++中的复制构造
函数，但它从未被隐式调用。</p>
<p>特别是Rc使用Clone作为增加引用计数的方法。因此，与其移动一个Box到子列表中，不如直接克
隆旧列表的头部。我们甚至不需要在头部进行匹配，因为Option暴露了一个Clone的实现，它所做
的正是我们想要的事情。</p>
<p>好了，让我们试一试吧：</p>
<pre><code class="language-rust ignore">pub fn append(&amp;self, elem: T) -&gt; List&lt;T&gt; {
    List { head: Some(Rc::new(Node {
        elem: elem,
        next: self.head.clone(),
    }))}
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/third.rs:10:5
   |
10 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/third.rs:11:5
   |
11 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>哇，Rust对实际使用字段真的很苛刻。它可以告诉没有消费者可以真正观察到这些字段的使用情
况! 不过，到目前为止，我们似乎还不错。</p>
<p><code>tail</code>是这个操作的逻辑逆运算。它接收一个列表并返回除去第一个元素的整个列表。所有这些
都是克隆列表中的<em>第二个</em>元素（如果它存在的话）。我们来试试这个：</p>
<pre><code class="language-rust ignore">pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().map(|node| node.next.clone()) }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0308]: mismatched types
  --&gt; src/third.rs:27:22
   |
27 |         List { head: self.head.as_ref().map(|node| node.next.clone()) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::rc::Rc`, found enum `std::option::Option`
   |
   = note: expected type `std::option::Option&lt;std::rc::Rc&lt;_&gt;&gt;`
              found type `std::option::Option&lt;std::option::Option&lt;std::rc::Rc&lt;_&gt;&gt;&gt;`
</code></pre>
<p>嗯，我们搞砸了。<code>map</code>希望我们返回一个Y，但是在这里我们要返回一个<code>Option&lt;Y&gt;</code>。值得庆
幸的是，这是另一个常见的Option模式，我们可以直接使用<code>and_then</code>来让我们返回一个Option。</p>
<pre><code class="language-rust ignore">pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>很好。</p>
<p>现在我们有了<code>tail</code>，我们也许应该提供<code>head</code>，它返回对第一个元素的引用。这只是从可
变列表中<code>peek</code>：</p>
<pre><code class="language-rust ignore">pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| &amp;node.elem )
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>很好。</p>
<p>这已经有足够的功能，我们可以测试它：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.append(1).append(2).append(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);

    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>很完美!</p>
<p>Iter也与我们的可变链表的情况相同：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-rust ignore">#[test]
fn iter() {
    let list = List::new().append(1).append(2).append(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 7 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>谁曾说过动态类型更容易？</p>
<p>(笨蛋说的)</p>
<p>注意，我们不能为这个类型实现IntoIter或IterMut。我们只有对元素的共享访问。</p>
<h1><a class="header" href="#丢弃-1" id="丢弃-1">丢弃</a></h1>
<p>像可变列表一样，我们有一个递归的析构器问题。诚然，对于不可变的列表来说，这并不是一
个糟糕的问题：如果我们遇到<em>某处</em>另一个节点是另一个列表的头，我们就不会递归地放弃它。
然而，这仍然是一个我们应该关心的问题，而且如何处理并不那么明确。下面是我们之前解决这
个问题的方法：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>问题在于循环的主体：</p>
<pre><code class="language-rust ignore">cur_link = boxed_node.next.take();
</code></pre>
<p>这是在盒子里改变节点，但我们不能用Rc做这个；它只给我们共享访问权，因为任何数量的其他
Rc都可能指向它。</p>
<p>但是如果我们知道我们是最后一个知道这个节点的列表，那么将节点移出Rc其实是可以的。那么
我们也可以知道什么时候停止：只要我们<em>不能</em>把Node吊出来。</p>
<p>看看这个，Rc有一个方法正是这样做的：<code>try_unwrap</code>：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/too-many-lists/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.10s
     Running /Users/ABeingessner/dev/too-many-lists/lists/target/debug/deps/lists-86544f1d97438f1f

running 8 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>好!
棒。</p>
<h1><a class="header" href="#arc" id="arc">Arc</a></h1>
<p>使用不可变链表的一个原因是跨线程共享数据。毕竟，共享可变的状态是所有邪恶的根源，
解决这个问题的一个方法是永远杀死<em>可变</em>的部分。</p>
<p>只是我们的列表根本就不是线程安全的。为了实现线程安全，我们需要<em>原子化</em>地处理引用
计数。否则，两个线程可以尝试增加引用计数，但<em>只有一个会发生</em>。那么，列表就会过早
地被释放！</p>
<p>为了获得线程安全，我们必须使用<em>Arc</em>。Arc与Rc完全相同，只是引用计数被原子化地修改。
如果你不需要的话，这有一点开销，所以Rust将两者都暴露出来。我们需要做的就是用
<code>std::sync::Arc</code>替换所有对Rc的引用，来制作我们的列表。就这样了。我们是线程安全
的。完成了!</p>
<p>但这提出了一个有趣的问题：我们如何<em>知道</em>一个类型是否是线程安全的？我们会不会不小心
搞砸了？</p>
<p>不会！在Rust中，你不可能搞乱线程安全。</p>
<p>之所以如此，是因为Rust通过两个特性以第一类的方式建立了线程安全模型。<code>Send</code>和
<code>Sync</code>。</p>
<p>如果一个类型可以安全地移动到另一个线程，那么它就是<em>Send</em>。如果一个类型在多个线程之
间<em>共享</em>是安全的，那么它就是<em>Sync</em>。也就是说，如果<code>T</code>是Sync，<code>&amp;T</code>就是Send。在这种
情况下，安全意味着不可能引起<em>数据竞争</em>，（不要误解为更普遍的<em>竞赛条件</em>问题）。</p>
<p>这些是标记特性，这是一种华丽的说法，即它们是完全不提供接口的特性。你要么<em>是</em>Send，
要么不是。这只是一个<em>其他</em>API可以要求的属性。如果你不是合适的Send，那么就不可能被发
送到不同的线程中。很好!</p>
<p>Send和Sync也是基于你是否完全由Send和Sync类型组成的自动派生特性。这类似于如果你只由
Copy类型组成，你只能实现Copy，但如果你是Copy类型，我们就自动去实现它。</p>
<p>几乎每个类型都是Send和Sync。大多数类型都是Send，因为它们完全拥有自己的数据。大多数
类型是Sync，因为跨线程共享数据的唯一方法是把它们放在一个共享引用后面，这使得它们是
不可改变的</p>
<p>然而，有一些特殊的类型违反了这些属性：那些具有<em>内部可变性</em>的类型。到目前为止，我们只
与<em>继承的可变性</em>（又称外部可变性）进行了真正的互动：一个值的可变性是从其容器的可变性
中继承的。也就是说，你不能因为你喜欢而随机地改变一个不可变的值的某个字段。</p>
<p>内部可变性类型违反了这一点：它们让你通过一个共享的引用进行改变。内部可变性有两大类：
单元格，它只在单线程环境下工作；锁，它在多线程环境下工作。由于显而易见的原因，当你可
以使用单元格时，单元格开销更小。还有atomics，它是类似于锁的基元。</p>
<p>那么这一切与Rc和Arc有什么关系呢？好吧，它们都使用内部可变性来表示它们的<em>引用计数</em>。
更糟的是，这个引用计数在每个实例之间都是共享的！Rc只是使用一个单元，这意味着它不是线程
安全的。Arc使用了一个原子，这意味着它<em>是</em>线程安全的。当然，你不可能通过把一个类型放在
Arc中而神奇地使它成为线程安全的。Arc只能像其他类型一样派生出线程安全。</p>
<p>我真的真的不想讨论原子内存模型或非派生Send实现的更多细节。不用说，当你深入了解Rust的线
程安全故事时，事情会变得更加复杂。作为一个高级消费者，这一切都<em>只是在工作</em>，你真的不需
要考虑它。</p>
<h1><a class="header" href="#final-code-1" id="final-code-1">Final Code</a></h1>
<p>That's all I really have to say on the immutable stack. We're getting pretty
good at implementing lists now!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn append(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }

    pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| &amp;node.elem)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.append(1).append(2).append(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // Make sure empty tail works
        let list = list.tail();
        assert_eq!(list.head(), None);
    }

    #[test]
    fn iter() {
        let list = List::new().append(1).append(2).append(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#一个不好但是安全的双链双向队列" id="一个不好但是安全的双链双向队列">一个不好但是安全的双链双向队列</a></h1>
<p>现在我们已经看到了Rc，并听说了内部可变性，这给我们一个有趣的想法......。也许我
们<em>可以</em>通过Rc进行改变。如果<em>是这样</em>，也许我们可以完全安全地实现一个<em>双链表</em>！</p>
<p>在这个过程中，我们将熟悉内部可变性，并可能了解到，安全并不意味着正确。双链表很
难，我总是在某个地方犯错。</p>
<p>让我们添加一个新的文件，叫做<code>fourth.rs</code>：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
</code></pre>
<p>这将是另一个净室操作，尽管像往常一样，我们可能会发现一些逻辑再次逐字适用。</p>
<p>免责声明：这一章基本上是一个示范，说明这是一个非常糟糕的主意。</p>
<h1><a class="header" href="#布局-1" id="布局-1">布局</a></h1>
<p>我们设计的关键是<code>RefCell</code>类型。RefCell的核心是一对方法：</p>
<pre><code class="language-rust ignore">fn borrow(&amp;self) -&gt; Ref&lt;'_, T&gt;;
fn borrow_mut(&amp;self) -&gt; RefMut&lt;'_, T&gt;;
</code></pre>
<p><code>borrow</code>和<code>borrow_mut</code>的规则正是<code>&amp;</code>和<code>&amp;mut</code>的规则：你可以随意调用<code>borrow</code>，但
<code>borrow_mut</code>需要独占性。</p>
<p>RefCell不是静态地执行这些规则，而是在运行时执行这些规则。如果你违反了这些规则，
RefCell就会惊慌失措，使程序崩溃。为什么它会返回这些Ref和RefMut的东西？好吧，它们的
行为基本上和<code>Rc</code>s一样，只是用于借用。它们也保持RefCell的借用，直到它们超出范围。我
们稍后会讨论这个问题。</p>
<p>现在有了Rc和RefCell，我们可以成为......一种令人难以置信的冗长的普遍可变异的垃圾收集
语言，它不能收集循环 呀呀呀...</p>
<p>好了，我们要做<em>双向链接</em>的。这意味着每个节点都有一个指向上一个和下一个节点的指针。同
时，列表本身也有一个指向第一个和最后一个节点的指针。这样我们就可以在列表的两端快速插
入和删除。</p>
<p>所以我们可能需要这样的东西：</p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::cell::RefCell;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/fourth.rs:5:5
  |
5 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `tail`
 --&gt; src/fourth.rs:6:5
  |
6 |     tail: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `next`
  --&gt; src/fourth.rs:13:5
   |
13 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^

warning: field is never used: `prev`
  --&gt; src/fourth.rs:14:5
   |
14 |     prev: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>嘿，它建好了! 很多死代码的警告，但它构建了！让我们试着使用它。</p>
<h1><a class="header" href="#构建" id="构建">构建</a></h1>
<p>好吧，我们先从建立链表开始。在这个新的系统中，这是很直接的事情。<code>new</code>仍然简单，
所有的字段都是None。另外，因为它变得有点不方便，我们也来做一个Node构造函数：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

**A BUNCH OF DEAD CODE WARNINGS BUT IT BUILT**
</code></pre>
<p>耶!</p>
<p>现在让我们试着把推入写到链表的前面。因为双链表明显更复杂，我们需要做更多的工作。
单链表的操作可以简化为一个简单的单行代码，而双链表的操作则相当复杂。</p>
<p>特别是我们现在需要特别处理一些围绕空列表的边界情况。大多数操作只涉及<code>head</code>或
<code>tail</code>的指针。然而当过渡到空列表或从空列表过渡时，我们需要<em>同时</em>编辑两个列表。</p>
<p>如果我们保持以下的不变性，我们验证我们的方法是否有意义的一个简单方法是：每个节
点应该正好有两个指向它的指针。列表中间的每个节点都被其前任和后任所指向，而两端
的节点则被列表本身所指向。</p>
<p>让我们来试一试：</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    // new node needs +2 links, everything else should be +0
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            // non-empty list, need to connect the old_head
            old_head.prev = Some(new_head.clone()); // +1 new_head
            new_head.next = Some(old_head);         // +1 old_head
            self.head = Some(new_head);             // +1 new_head, -1 old_head
            // total: +2 new_head, +0 old_head -- OK!
        }
        None =&gt; {
            // empty list, need to set the tail
            self.tail = Some(new_head.clone());     // +1 new_head
            self.head = Some(new_head);             // +1 new_head
            // total: +2 new_head -- OK!
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0609]: no field `prev` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:39:26
   |
39 |                 old_head.prev = Some(new_head.clone()); // +1 new_head
   |                          ^^^^ unknown field

error[E0609]: no field `next` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:40:26
   |
40 |                 new_head.next = Some(old_head);         // +1 old_head
   |                          ^^^^ unknown field
</code></pre>
<p>好吧。编译器错误。好的开始。好的开始。</p>
<p>为什么我们不能访问我们节点上的<code>prev</code>和<code>next</code>字段？以前当我们只有一个<code>Rc&lt;Node&gt;</code>的
时候，它是可以工作的。似乎<code>RefCell</code>妨碍了它。</p>
<p>我们也许应该检查一下文档。</p>
<p><em>谷歌一下&quot;rust refcell&quot;</em></p>
<p><em><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">点击第一个链接</a></em></p>
<blockquote>
<p>一个具有动态检查的借用规则的可变的内存位置</p>
<p>参见<a href="https://doc.rust-lang.org/std/cell/index.html">模块级文档</a>以了解更多。</p>
</blockquote>
<p><em>点击链接</em></p>
<blockquote>
<p>可共享的可变异容器。</p>
<p><code>Cell&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>类型的值可以通过共享引用（即常见的<code>&amp;T</code>类型）进行改变
，而大多数Rust类型只能通过唯一的（<code>&amp;mut T</code>）引用进行变异。我们说<code>Cell&lt;T&gt;</code>和
<code>RefCell</code><T>提供了 &quot;内部可变性&quot;，而典型的Rust类型则表现为 &quot;继承的可变性&quot;。</p>
<p>细胞类型有两种风格：<code>Cell&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>。<code>Cell&lt;T&gt;</code>提供了<code>get</code>和<code>set</code>方
法，只需调用一个方法就可以改变内部值。不过<code>Cell&lt;T&gt;</code>只与实现Copy的类型兼容。对
于其他类型，必须使用<code>RefCell&lt;T&gt;</code>类型，在改变之前获得一个写锁。</p>
<p><code>RefCell</code><T>使用Rust的生命周期来实现 &quot;动态借用&quot;，在这个过程中，我们可以要求对
内部值进行临时的、独占的、可改变的访问。<code>RefCell&lt;T&gt;</code>的借用是在&quot;运行时&quot;跟踪的，
而不像Rust的本地引用类型那样完全是在编译时静态跟踪的。因为<code>RefCell&lt;T&gt;</code>的借用是
动态的，所以有可能试图借用一个已经被变异借用的值；当这种情况发生时，会导致线程恐
慌。</p>
<h1><a class="header" href="#何时选择内部可变性" id="何时选择内部可变性">何时选择内部可变性</a></h1>
<p>更常见的继承可变性，即必须有唯一的访问权才能改变一个值，这是一个关键的语言元素，
使Rust能够强有力地推理指针别名，静态地防止崩溃的错误。正因为如此，继承的可变性是
首选，而内部可变性是最后的手段。由于单元格类型能够在原本不允许的地方进行改变，所
以在某些情况下，内部变异可能是合适的，甚至是<em>必须</em>使用的，比如说</p>
<ul>
<li>为共享类型引入继承的可变性根源。</li>
<li>逻辑上不可变的方法的实现细节。</li>
<li><code>Clone</code>的可变实现。</li>
</ul>
<h2><a class="header" href="#为共享类型引入继承的可变性根基" id="为共享类型引入继承的可变性根基">为共享类型引入继承的可变性根基</a></h2>
<p>共享的智能指针类型，包括<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>，提供了可以在多方之间克隆和共享的容器
。因为所包含的值可能是多重别名的，所以它们只能作为共享引用被借用，而不是可变型引用
。如果没有单元格，就根本不可能对共享盒内的数据进行变异！</p>
<p>因此，在共享指针类型内放置一个<code>RefCell&lt;T&gt;</code>以重新引入可变性是非常常见的：</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre>
<p>注意这个例子使用了<code>Rc&lt;T&gt;</code>而不是<code>Arc&lt;T&gt;</code>。<code>RefCell&lt;T&gt;</code>是用于单线程的情况。如果你在
多线程情况下需要共享可变性，请考虑使用<code>Mutex&lt;T&gt;</code>。</p>
</blockquote>
<p>嘿，Rust的文档仍然是令人难以置信的棒。</p>
<p>我们关心的主要内容是这一行：</p>
<pre><code class="language-rust ignore">shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
</code></pre>
<p>特别是<code>borrow_mut</code>的事情。似乎我们需要明确地借用一个RefCell。<code>.</code>运算符不会为我
们这样做。很奇怪。让我们试试：</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            old_head.borrow_mut().prev = Some(new_head.clone());
            new_head.borrow_mut().next = Some(old_head);
            self.head = Some(new_head);
        }
        None =&gt; {
            self.tail = Some(new_head.clone());
            self.head = Some(new_head);
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>嘿，它构建了！文档又赢了。</p>
<h1><a class="header" href="#崩溃" id="崩溃">崩溃</a></h1>
<p><code>pop_front</code>应该是与<code>push_front</code>相同的基本逻辑，但要倒过来。我们来试试：</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    // need to take the old head, ensuring it's -2
    self.head.take().map(|old_head| {                         // -1 old
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {                               // -1 new
                // not emptying list
                new_head.borrow_mut().prev.take();            // -1 old
                self.head = Some(new_head);                   // +1 new
                // total: -2 old, +0 new
            }
            None =&gt; {
                // emptying list
                self.tail.take();                             // -1 old
                // total: -2 old, (no new)
            }
        }
        old_head.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `elem` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:64:22
   |
64 |             old_head.elem
   |                      ^^^^ unknown field
</code></pre>
<p>啊。<em>RefCells</em>. 我想，又得<code>borrow_mut</code>了...</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|old_head| {
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {
                new_head.borrow_mut().prev.take();
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail.take();
            }
        }
        old_head.borrow_mut().elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/fourth.rs:64:13
   |
64 |             old_head.borrow_mut().elem
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p><em>叹息</em></p>
<blockquote>
<p>不能移出借用的内容</p>
</blockquote>
<p>嗯... 看来盒子真的是宠坏了我们。<code>borrow_mut</code>只能得到一个<code>&amp;mut Node&lt;T&gt;</code>，但我
们不能从那里移出！</p>
<p>我们需要一个能接收<code>RefCell&lt;T&gt;</code>并给我们一个<code>T</code>的东西，让我们看看<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">文档</a>
中是否有这样的东西：</p>
<blockquote>
<p><code>fn into_inner(self) -&gt; T</code></p>
<p>消费RefCell，返回被包装的值。</p>
</blockquote>
<p>这看起来很有希望！</p>
<pre><code class="language-rust ignore">old_head.into_inner().elem
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of an `Rc`
  --&gt; src/fourth.rs:64:13
   |
64 |             old_head.into_inner().elem
   |             ^^^^^^^^ cannot move out of an `Rc`
</code></pre>
<p>啊偶。<code>into_inner</code>想要移出RefCell，但是我们不能，因为它在一个<code>Rc</code>中。正如我们在上一章看到的，
<code>Rc&lt;T&gt;</code>只允许我们把共享的引用移到它的内部。这是有道理的，因为这就是引用计数指针的<em>全部意义</em>：
它们是共享的！</p>
<p>当我们想为我们的引用计数列表实现Drop时，这是一个问题，解决方案也是一样的：<code>Rc::try_unwrap</code>，
如果一个Rc的refcount是1，它将移出其内容。</p>
<pre><code class="language-rust ignore">Rc::try_unwrap(old_head).unwrap().into_inner().elem
</code></pre>
<p><code>Rc::try_unwrap</code>返回一个<code>Result&lt;T, Rc&lt;T&gt;&gt;</code>。结果基本上是一个广义的<code>Option</code>，
其中<code>None</code>的情况下有数据与之相关。在这种情况下，就是你试图解包的<code>Rc</code>。由于我们并
不关心它失败的情况（如果我们的程序写得正确，它一定会成功），我们只是对它调用
<code>unwrap</code>。</p>
<p>总之，让我们看看接下来会出现什么编译器错误（让我们面对现实吧，一定会有的）。</p>
<pre><code class="language-text">&gt; cargo build

error[E0599]: no method named `unwrap` found for type `std::result::Result&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;, std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;&gt;` in the current scope
  --&gt; src/fourth.rs:64:38
   |
64 |             Rc::try_unwrap(old_head).unwrap().into_inner().elem
   |                                      ^^^^^^
   |
   = note: the method `unwrap` exists but the following trait bounds were not satisfied:
           `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt; : std::fmt::Debug`
</code></pre>
<p>UGH.Result上的<code>unwrap</code>要求你能调试打印出错的情况。<code>RefCell&lt;T&gt;</code>只有在<code>T</code>实现时才实现
<code>Debug</code>。<code>Node</code>并没有实现Debug。</p>
<p>与其这样做，不如通过将Result转换为一个带有<code>ok</code>的Option来解决这个问题：</p>
<pre><code class="language-rust ignore">Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
</code></pre>
<p>请。</p>
<pre><code class="language-text">cargo build

</code></pre>
<p>对了。</p>
<p><em>呼</em></p>
<p>我们做到了。</p>
<p>我们应用了<code>push</code>和<code>pop</code>。</p>
<p>让我们通过窃取旧的<code>stack</code>基本测试来进行测试（因为这就是我们到目前为止所实现的全
部）：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 9 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::basics ... ok
test fifth::test::iter_mut ... ok
test third::test::basics ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p><em>钉住了</em>。</p>
<p>现在我们可以正确地从列表中删除东西，我们可以实现Drop。这次的Drop在概念上更加有趣。
以前我们费力地为我们的堆栈实现Drop只是为了避免无界递归，现在我们需要实现Drop才能
让<em>任何事情</em>发生。</p>
<p><code>Rc</code>不能处理循环。如果有一个循环，所有的东西都会让其他的东西活着。事实证明，一个
双向链接的列表只是一个由微小的循环组成的大链子！因此，当我们放弃我们的列表时，两
个末端节点的refcounts将被递减到1......然后就不会再发生什么了。好吧，如果我们的列
表正好包含一个节点，我们就可以了。但理想情况下，如果一个列表包含多个元素，它就应
该正常工作。也许这只是我的问题。</p>
<p>正如我们所看到的，删除元素是有点痛苦的。所以对我们来说，最简单的事情就是<code>pop</code>，直
到我们得到None：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
</code></pre>
<pre><code class="language-text">cargo build

</code></pre>
<p>(我们实际上可以用我们的可变堆栈做到这一点，但捷径是给那些理解事物的人的！)</p>
<p>我们可以考虑实现<code>push</code>和<code>pop</code>的<code>_back</code>版本，但这只是复制粘贴的工作，我们将在本章的
后面进行讨论。现在，让我们看看更有趣的事情吧！</p>
<h1><a class="header" href="#选择-1" id="选择-1">选择</a></h1>
<p>好了，我们用<code>push</code>和<code>pop</code>做。不瞒你说，我在那里有点情绪化了。编译时的正确性是
一种可怕的毒药。</p>
<p>让我们做一些简单的事情来冷静一下：让我们实现<code>peek_front</code>。这在以前是非常容易
的。应该还是很容易的，对吗？</p>
<p>对吗？</p>
<p>事实上，我想我可以直接复制粘贴它！&quot;。</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<p>等等。不是这时候。</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        // BORROW!!!!
        &amp;node.borrow().elem
    })
}
</code></pre>
<p>哈。</p>
<pre><code class="language-text">cargo build

error[E0515]: cannot return value referencing temporary value
  --&gt; src/fourth.rs:66:13
   |
66 |             &amp;node.borrow().elem
   |             ^   ----------^^^^^
   |             |   |
   |             |   temporary value created here
   |             |
   |             returns a value referencing data owned by the current function
</code></pre>
<p>好吧，我只是在烧我的电脑。</p>
<p>这与我们的单链栈的逻辑完全相同。为什么事情会不同。为什么。</p>
<p>答案其实就是本章的全部寓意。RefCells使一切变得悲伤。到现在为止，RefCells只是一个讨
厌的东西。现在它们将成为一场噩梦。</p>
<p>那么发生了什么？为了理解这一点，我们需要回到<code>borrow</code>的定义上：</p>
<pre><code class="language-rust ignore">fn borrow&lt;'a&gt;(&amp;'a self) -&gt; Ref&lt;'a, T&gt;
fn borrow_mut&lt;'a&gt;(&amp;'a self) -&gt; RefMut&lt;'a, T&gt;
</code></pre>
<p>在布局部分，我们说：</p>
<blockquote>
<p>RefCell不是静态地执行这些规则，而是在运行时执行它们。
如果你违反了这些规则，RefCell就会惊慌失措，使程序崩溃。
为什么它会返回这些Ref和RefMut的东西？好吧，它们的行为基本上和<code>Rc</code>s一样，只是用于借用。
另外，它们保持RefCell的借用，直到它们超出范围。<strong>我们稍后会讨论这个问题。</strong></p>
</blockquote>
<p>现在就是那个稍后。</p>
<p><code>Ref</code>和<code>RefMut</code>分别实现了<code>Deref</code>和<code>DerefMut</code>。因此，就大多数意图和目的而言，它们
的行为与<code>&amp;T</code>和<code>&amp;mut T</code><em>完全</em>一样。然而，由于这些特性的工作方式，被返回的引用与引用
的生命周期有关，而不是与实际的RefCell有关。这意味着，只要我们保留引用，Ref就必须一直
存在。</p>
<p>事实上，这对于正确性是必要的。当一个Ref被放弃时，它告诉RefCell它不再被借用。因此，如
果我们<em>确实</em>设法保持我们的引用比引用存在的时间长，我们就可以在引用四处游荡时得到一个
RefMut，并完全破坏Rust的类型系统的一半。</p>
<p>那么，这让我们怎么办呢？我们只想返回一个引用，但我们需要保持这个引用的存在。但是一旦
我们从<code>peek</code>中返回引用，函数就结束了，而<code>Ref</code>就出了范围。</p>
<p>😖</p>
<p>据我所知，我们在这里实际上已经完全陷入了困境。你不能像这样把RefCells的使用完全封装起来。</p>
<p>但是......如果我们放弃了完全隐藏我们的实现细节呢？如果我们返回Refs呢？</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        node.borrow()
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0412]: cannot find type `Ref` in this scope
  --&gt; src/fourth.rs:63:40
   |
63 |     pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
   |                                        ^^^ not found in this scope
help: possible candidates are found in other modules, you can import them into scope
   |
1  | use core::cell::Ref;
   |
1  | use std::cell::Ref;
   |
</code></pre>
<p>啊这。要导入一些东西。</p>
<pre><code class="language-rust ignore">use std::cell::{Ref, RefCell};
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/fourth.rs:64:9
   |
64 | /         self.head.as_ref().map(|node| {
65 | |             node.borrow()
66 | |         })
   | |__________^ expected type parameter, found struct `fourth::Node`
   |
   = note: expected type `std::option::Option&lt;std::cell::Ref&lt;'_, T&gt;&gt;`
              found type `std::option::Option&lt;std::cell::Ref&lt;'_, fourth::Node&lt;T&gt;&gt;&gt;`
</code></pre>
<p>嗯...这就对了。我们有一个<code>Ref&lt;Node&lt;T&gt;&gt;</code>，但是我们想要一个<code>Ref&lt;T&gt;</code>。我们可以放弃所
有封装的希望，直接返回它。我们也可以把事情搞得更复杂，把<code>Ref&lt;Node&lt;T&gt;&gt;</code>包装成一个新
的类型，只暴露对<code>&amp;T</code>的访问。</p>
<p>这两种方法都<em>有点</em>蹩脚。</p>
<p>相反，我们要更深入地去做。让我们找点<em>乐子</em>。我们的乐趣之源是这只<em>野兽</em>：</p>
<pre><code class="language-rust ignore">map&lt;U, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt;
    where F: FnOnce(&amp;T) -&gt; &amp;U,
          U: ?Sized
</code></pre>
<blockquote>
<p>为借来的数据的一个组成部分做一个新的参考。</p>
</blockquote>
<p>是的：就像你可以映射一个Option，你也可以映射一个Ref。</p>
<p>我相信某些人真的很兴奋，因为<em>单体</em>或其他什么，但我并不关心这些。我也不认为这是一个合
适的单体，因为没有None-like的情况，但我离题了。</p>
<p>它很酷，这对我来说才是最重要的。<em>我需要这个</em>。</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
</code></pre>
<p>啊耶。</p>
<p>让我们通过从我们的堆栈中插入测试来确保它的工作。我们需要做一些处理，以应对Refs不实
现比较的事实。</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
}
</code></pre>
<pre><code>&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok
test second::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>棒！</p>
<h1><a class="header" href="#对称的垃圾" id="对称的垃圾">对称的垃圾</a></h1>
<p>好了，让我们把所有的组合对称性问题都解决了。</p>
<p>我们所要做的就是一些基本的文本替换：</p>
<pre><code class="language-text">tail &lt;-&gt; head
next &lt;-&gt; prev
front -&gt; back
</code></pre>
<p>哦，我们还需要为选取增加<code>_mut</code>的变体。</p>
<pre><code class="language-rust ignore">pub fn push_back(&amp;mut self, elem: T) {
    let new_tail = Node::new(elem);
    match self.tail.take() {
        Some(old_tail) =&gt; {
            old_tail.borrow_mut().next = Some(new_tail.clone());
            new_tail.borrow_mut().prev = Some(old_tail);
            self.tail = Some(new_tail);
        }
        None =&gt; {
            self.head = Some(new_tail.clone());
            self.tail = Some(new_tail);
        }
    }
}

pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.tail.take().map(|old_tail| {
        match old_tail.borrow_mut().prev.take() {
            Some(new_tail) =&gt; {
                new_tail.borrow_mut().next.take();
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head.take();
            }
        }
        Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
    })
}

pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}

pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}

pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}
</code></pre>
<p>并大规模地充实我们的测试：</p>
<pre><code class="language-rust ignore">#[test]
fn basics() {
    let mut list = List::new();

    // Check empty list behaves right
    assert_eq!(list.pop_front(), None);

    // Populate list
    list.push_front(1);
    list.push_front(2);
    list.push_front(3);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(3));
    assert_eq!(list.pop_front(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_front(4);
    list.push_front(5);

    // Check normal removal
    assert_eq!(list.pop_front(), Some(5));
    assert_eq!(list.pop_front(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_front(), Some(1));
    assert_eq!(list.pop_front(), None);

    // ---- back -----

    // Check empty list behaves right
    assert_eq!(list.pop_back(), None);

    // Populate list
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(3));
    assert_eq!(list.pop_back(), Some(2));

    // Push some more just to make sure nothing's corrupted
    list.push_back(4);
    list.push_back(5);

    // Check normal removal
    assert_eq!(list.pop_back(), Some(5));
    assert_eq!(list.pop_back(), Some(4));

    // Check exhaustion
    assert_eq!(list.pop_back(), Some(1));
    assert_eq!(list.pop_back(), None);
}

#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    assert!(list.peek_back().is_none());
    assert!(list.peek_front_mut().is_none());
    assert!(list.peek_back_mut().is_none());

    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
    assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
    assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
    assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
}
</code></pre>
<p>是否有一些情况我们没有测试？可能吧。组合空间在这里真的炸开了锅。我们的代码至少
没有<em>明显的错误</em>。</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>不错。复制-粘贴是最好的编程方式。</p>
<h1><a class="header" href="#迭代" id="迭代">迭代</a></h1>
<p>让我们来试着迭代这个坏小子。</p>
<h2><a class="header" href="#intoiter" id="intoiter">IntoIter</a></h2>
<p>IntoIter和往常一样，是最简单的。只是包装了栈并调用<code>pop</code>：</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}
</code></pre>
<p>但我们有一个有趣的新发展。以前，我们的列表只有一种&quot;自然&quot;的迭代顺序，而双向队列本
身就是双向的。从前到后有什么特别之处？如果有人想从另一个方向迭代呢？</p>
<p>Rust实际上对此有一个答案：<code>DoubleEndedIterator</code>。DoubleEndedIterator<em>继承</em>自
Iterator（意味着所有的DoubleEndedIterator都是Iterators），并且需要一个新方法：
<code>next_back</code>。它的签名与<code>next</code>完全相同，但它应该从另一端产生元素。
DoubleEndedIterator的语义对我们来说是非常方便的：迭代器成为一个双向队列。你可以
从前面和后面消耗元素，直到两端汇合，这时迭代器是空的。</p>
<p>与Iterator和<code>next</code>一样，事实证明<code>next_back</code>并不是DoubleEndedIterator的消费者
真正关心的东西。相反，这个接口最好的部分是它暴露了<code>rev</code>方法，它将迭代器包装起来，
形成一个新的迭代器，以相反的顺序产生元素。这方面的语义是相当直接的：对反向迭代器
的<code>next</code>的调用只是对<code>next_back</code>的调用。</p>
<p>总之，因为我们已经是一个双向队列，所以提供这个API是非常容易的：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}
</code></pre>
<p>然后让我们测试它：</p>
<pre><code class="language-rust ignore">#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::iter ... ok
test third::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>好。</p>
<h2><a class="header" href="#iter" id="iter">Iter</a></h2>
<p>Iter的宽容度会低一些。我们将不得不再次处理那些可怕的<code>Ref</code>的东西 由于Refs的存在，
我们不能像以前那样存储<code>&amp;Nodes</code>。相反，让我们尝试存储<code>Ref&lt;Node&gt;</code>s：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt;(Option&lt;Ref&lt;'a, Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>到目前为止还不错。<code>next</code>的实现会有点棘手，但我认为它与旧的堆栈IterMut的基本逻辑
是一样的，只是多了RefCell的疯狂：</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = Ref&lt;'a, T&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node_ref| {
            self.0 = node_ref.next.as_ref().map(|head| head.borrow());
            Ref::map(node_ref, |node| &amp;node.elem)
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0521]: borrowed data escapes outside of closure
   --&gt; src/fourth.rs:155:13
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- `self` is declared here, outside of the closure body
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   -------- borrow is only valid in the closure body
    |             |
    |             reference to `node_ref` escapes the closure body here

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --&gt; src/fourth.rs:156:22
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- lifetime `'1` appears in the type of `self`
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ------   -------- borrow of `node_ref` occurs here
    |             |
    |             assignment requires that `node_ref` is borrowed for `'1`
156 |             Ref::map(node_ref, |node| &amp;node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here
</code></pre>
<p>完成。</p>
<p><code>node_ref</code>的生命周期不够长。与普通的引用不同，Rust不允许我们像这样把Ref拆开。我们从
<code>head.borrow()</code>中得到的Ref只允许活得和<code>node_ref</code>一样长，但我们最终在<code>Ref::map</code>
的调用中破坏了它。</p>
<p>巧合的是，就在我写这篇文章的时候，我们想要的函数实际上在两天前就已经稳定了。这意味着它
将在几个月后进入稳定版。所以让我们继续使用最新的每夜构建：</p>
<pre><code class="language-rust ignore">pub fn map_split&lt;U, V, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; (Ref&lt;'b, U&gt;, Ref&lt;'b, V&gt;) where
    F: FnOnce(&amp;T) -&gt; (&amp;U, &amp;V),
    U: ?Sized,
    V: ?Sized,
</code></pre>
<p>芜湖。让我们试一试...</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&amp;node.next, &amp;node.elem)
        });

        self.0 = next.as_ref().map(|head| head.borrow());

        elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0521]: borrowed data escapes outside of closure
   --&gt; src/fourth.rs:159:13
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- `self` is declared here, outside of the closure body
...
159 |             self.0 = next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   ---- borrow is only valid in the closure body
    |             |
    |             reference to `next` escapes the closure body here
</code></pre>
<p>Ergh. 我们需要再次使用<code>Ref::Map</code>来使我们的生命周期正确。但是<code>Ref::Map</code>返回一个
<code>Ref</code>，我们需要一个<code>Option&lt;Ref&gt;</code>，但是我们需要通过Ref来映射我们的Option......</p>
<p><strong>盯着远方看了很久</strong></p>
<p>??????</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&amp;node.next, &amp;node.elem)
        });

        self.0 = if next.is_some() {
            Some(Ref::map(next, |next| &amp;**next.as_ref().unwrap()))
        } else {
            None
        };

        elem
    })
}
</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/fourth.rs:162:22
    |
162 |                 Some(Ref::map(next, |next| &amp;**next.as_ref().unwrap()))
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `fourth::Node`, found struct `std::cell::RefCell`
    |
    = note: expected type `std::cell::Ref&lt;'_, fourth::Node&lt;_&gt;&gt;`
               found type `std::cell::Ref&lt;'_, std::cell::RefCell&lt;fourth::Node&lt;_&gt;&gt;&gt;`
</code></pre>
<p>哦。对。这里有多个RefCell。我们在列表中走得越深，每个RefCell下的嵌套就越多。我们需要
维护，比如说，一个堆栈的Refs来代表我们持有的所有未偿借贷，因为如果我们停止查看一个元
素，我们需要递减它之前的每个RefCell的借用计数.................</p>
<p>我不认为我们在这里有什么可以做的。这是个死胡同。让我们试着离开RefCell。</p>
<p>那我们的<code>Rc</code>s呢？谁说我们甚至需要存储引用？为什么我们不能克隆整个Rc，以获得一个漂亮的
自己的解决方案到列表的中间？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;T&gt;(Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item =
#}</code></pre></pre>
<p>呃......等等，我们现在返回什么？ <code>&amp;T</code>？<code>Ref&lt;T&gt;</code>？</p>
<p>不，这些都不行......我们的Iter已经没有生命周期了！<code>&amp;T</code>和<code>Ref&lt;T&gt;</code>都要求我们在进
入下一步之前先声明一些生命周期。但是我们设法从Rc中得到的任何东西都会借用迭代
器......脑子......受伤了......啊啊啊啊啊啊</p>
<p>也许我们可以......映射......Rc......得到一个<code>Rc&lt;T&gt;</code>？这是个问题吗？Rc的文档似乎
没有这样的东西。事实上，有人做了一个<a href="https://crates.io/crates/owning_ref">板条箱</a>，可以让你这样做。</p>
<p>但是等等，即使我们<em>这样</em>做了，我们也有一个更大的问题：如幽灵般可怕的迭代器失效。
以前我们对迭代器失效完全免疫，因为Iter借用了列表，使其完全不可改变。然而，如果我
们的 Iter 产生了 Rcs，他们就根本不会借用列表了！这意味着人们可以在持有指向列表的
指针时开始调用<code>push</code>和<code>pop</code>。</p>
<p>哦，天哪，那会怎么样？</p>
<p>好吧，推入其实是可以的。我们已经得到了一个进入列表的某个子范围的视图，而列表只是在
我们的视线之外增长。没什么大不了的。</p>
<p>然而<code>pop</code>是另一个故事。如果他们在我们的范围之外弹出元素，应该<em>还</em>是可以的。我们看
不到那些节点，所以不会发生什么。然而，如果他们试图从我们指向的节点上弹出......一切
都会被炸毁！特别是当他们去<code>unwrap</code> <code>try_unwrap</code>的结果时，实际上会失败，整个程序
会恐慌。</p>
<p>这实际上是非常酷的。我们可以把大量的内部拥有的指针放入列表中，并同时对其进行改变，
它就<em>会一直工作</em>，直到他们试图删除我们所指向的节点。即使如此，我们也不会出现悬空指
针或任何东西，程序会确定地发生恐慌！</p>
<p>但是在映射Rc的基础上还要处理迭代器失效的问题，这似乎......很糟糕。<code>Rc&lt;RefCell&gt;</code>
真的真的终于让我们失望了。有趣的是，我们经历了持久化堆栈案例的反转。持久堆栈努力地
收回数据的所有权，但每天都能得到引用，而我们的列表在获得所有权方面没有问题，但在借
出引用方面却非常困难。</p>
<p>尽管公平地说，我们的大部分挣扎都是围绕着想要隐藏实现细节和拥有一个体面的API。如果我
们想在所有地方传递节点，我们<em>可以</em>做得很好。</p>
<p>见鬼，我们可以制作多个并发的IterMuts，这些IterMuts在运行时被检查为不可改变地访问同
一个元素！这就是我们的设计。</p>
<p>实际上，这种设计更适合于内部数据结构，因为它永远不会让API的消费者看到。内部可变性对
于编写安全的<em>应用程序</em>是很好的。但对于安全的<em>库</em>来说就不是那么回事了。</p>
<p>总之，我放弃了Iter和IterMut。我们可以做它们，但是<em>唉</em>。</p>
<h1><a class="header" href="#最终代码" id="最终代码">最终代码</a></h1>
<p>好了，这就是在Rust中实现了一个100%安全的双链接列表。它的实现是一场噩梦，泄露了实现细
节，而且不支持几个基本操作。</p>
<p>但是，它存在。</p>
<p>哦，我猜它还充斥着大量&quot;不必要的&quot;<code>Rc</code>和<code>RefCell</code>之间正确性的运行时检查。我把&quot;不必要&quot;
加了引号，因为它们对于保证整个实际安全的事情来说是必要的。我们遇到了一些地方，这些检
查实际上是必要的。双重链接的列表有一个可怕的纠缠不清的别名和所有权的故事!</p>
<p>不过，这也是我们可以做的事情。特别是如果我们不关心向消费者暴露内部数据结构的话。</p>
<p>从这里开始，我们将专注于这个硬币的另一面：通过使我们的实现<em>不安全</em>来夺回所有控制权。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::{Ref, RefMut, RefCell};

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}


impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) =&gt; {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail = Some(new_head.clone());
                self.head = Some(new_head);
            }
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) =&gt; {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail);
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) =&gt; {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None =&gt; {
                    self.head.take();
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|old_head| {
            match old_head.borrow_mut().next.take() {
                Some(new_head) =&gt; {
                    new_head.borrow_mut().prev.take();
                    self.head = Some(new_head);
                }
                None =&gt; {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }

    pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop_front(), None);

        // Populate list
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_front(4);
        list.push_front(5);

        // Check normal removal
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);

        // ---- back -----

        // Check empty list behaves right
        assert_eq!(list.pop_back(), None);

        // Populate list
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push_back(4);
        list.push_back(5);

        // Check normal removal
        assert_eq!(list.pop_back(), Some(5));
        assert_eq!(list.pop_back(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert!(list.peek_front().is_none());
        assert!(list.peek_back().is_none());
        assert!(list.peek_front_mut().is_none());
        assert!(list.peek_back_mut().is_none());

        list.push_front(1); list.push_front(2); list.push_front(3);

        assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
        assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
        assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
        assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push_front(1); list.push_front(2); list.push_front(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next_back(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#一个不安全的单连接队列" id="一个不安全的单连接队列">一个不安全的单连接队列</a></h1>
<p>好吧，那个引用计算的内部可变性的东西有点失控了。当然，Rust并不希望你在一般
情况下做这样的事情？嗯，是的，也不是。Rc和Refcell可以很好地处理简单的情况，
但它们可能会变得不方便。特别是如果你想隐藏它的发生。一定会有更好的方法!</p>
<p>在这一章中，我们将回到单链列表，并实现一个单链队列，来尝试一下原始指针和<em>不
安全的Rust</em>。</p>
<p>让我们添加一个名为<code>fifth.rs</code>的新文件：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
pub mod fifth;
</code></pre>
<p>我们的代码主要来自second.rs，因为队列在链表的世界里主要是对堆栈的一种增强。不过，
我们还是要从头开始，因为我们要解决一些关于布局和其他方面的基本问题。</p>
<h1><a class="header" href="#布局-2" id="布局-2">布局</a></h1>
<p>那么，单链队列是什么样的呢？好吧，当我们有一个单链接的堆栈时，我们推到列表的一端，
然后从同一端弹出。栈和队列的唯一区别是，队列会从<em>另</em>一端弹出。所以从我们的堆栈实现
来看，我们有：</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

stack push X:
[Some(ptr)] -&gt; (X, Some(ptr)) -&gt; (A, Some(ptr)) -&gt; (B, None)

stack pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>要制作一个队列，我们只需要决定将哪个操作移到列表的末尾：推，还是弹？由于我们的列表
是单链的，我们实际上可以用同样的努力把<em>任何一个</em>操作移到最后。</p>
<p>要把<code>push</code>移到最后，我们只需一路走到<code>None</code>，并把它和新元素一起设置为Some。</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

flipped push X:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)
</code></pre>
<p>要把<code>pop</code>移到最后，我们只需一路走到None<em>之前</em>的节点，然后<code>take</code>它：</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)

flipped pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>我们今天可以做这个，然后就不干了，但那会很臭！。这两种操作都是在<em>整个</em>列表上行走。有
些人认为，这样的队列实现确实是一个队列，因为它暴露了正确的接口。然而我认为性能保证是
接口的一部分。我不关心精确的渐近界线，只关心“快”与“慢”。队列保证推送和弹出是快速的，
而在整个列表上行走肯定是<em>不</em>快的。</p>
<p>一个关键的观察是，我们在重复做<em>同样的事情</em>，浪费了大量的工作。我们能不能把这项工作记
忆化？为什么，是的？我们可以存储一个指向列表末尾的指针，然后直接跳到那里去！</p>
<p>事实证明，只有一种反转的<code>push</code>和<code>pop</code>方式可以使用。要反转<code>pop</code>，我们必须将“尾部”指针
向后移动，但由于我们的列表是单链的，我们无法有效地做到这一点。如果我们反转<code>push</code>，我
们只需要将“头部”指针向前移动，这很容易。</p>
<p>让我们试试吧：</p>
<pre><code class="language-rust ignore">use std::mem;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // swap the old tail to point to the new tail
        let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));

        match old_tail {
            Some(mut old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
            }
        }
    }
}
</code></pre>
<p>由于我们对这种事情应该很熟悉，所以我现在在实现细节方面走得快一点。并不是说你应该期望
在第一次尝试时就能产生这样的代码。我只是跳过了一些我们以前不得不处理的试验和错误。实
际上，我在写这段代码时犯了很多错误，我没有显示出来。你只能看到我漏掉了<code>mut</code>或<code>;</code>这么
多次，然后它就不再具有指导意义了。别担心，我们会看到很多<em>其他的</em>错误信息的！</p>
<pre><code class="language-text">&gt; cargo build

error[E0382]: use of moved value: `new_tail`
  --&gt; src/fifth.rs:38:38
   |
26 |         let new_tail = Box::new(Node {
   |             -------- move occurs because `new_tail` has type `std::boxed::Box&lt;fifth::Node&lt;T&gt;&gt;`, which does not implement the `Copy` trait
...
33 |         let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));
   |                                                          -------- value moved here
...
38 |                 old_tail.next = Some(new_tail);
   |                                      ^^^^^^^^ value used here after move
</code></pre>
<p>发现了！</p>
<blockquote>
<p>使用了移动过的值： <code>new_tail</code></p>
</blockquote>
<p>盒子没有实现复制，所以我们不能直接把它分配到两个位置。更重要的是，Box<em>拥有</em>它所指向
的东西，当它被丢弃时，会尝试释放它。如果我们的<code>push</code>实现被编译了，我们就会把列表的
尾部释放出来。实际上，按照写法，我们的代码会在每次推送时释放 old_tail。呀! 🙀</p>
<p>好了，我们知道如何制作一个不能拥有的指针。这只是一个引用！</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
</code></pre>
<p>这里没有什么太棘手的问题。与前面的代码的基本思路相同，只是我们使用了一些隐含返回的
好处，从我们放置实际Box的地方提取尾部引用。</p>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
 --&gt; src/fifth.rs:3:18
  |
3 |     tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
  |                  ^ expected lifetime parameter
</code></pre>
<p>哦，对了，我们需要在类型的生命期中给出参考。嗯......这个引用的生命期是多少？嗯，
这好像是IterMut，对吗？让我们试试我们为IterMut所做的，只是添加一个通用的<code>'a</code>：</p>
<pre><code class="language-rust ignore">pub struct List&lt;'a, T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
  --&gt; src/fifth.rs:35:27
   |
35 |                 self.head.as_deref_mut()
   |                           ^^^^^^^^^^^^
   |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 18:5...
  --&gt; src/fifth.rs:18:5
   |
18 | /     pub fn push(&amp;mut self, elem: T) {
19 | |         let new_tail = Box::new(Node {
20 | |             elem: elem,
21 | |             // When you push onto the tail, your next is always None
...  |
39 | |         self.tail = new_tail;
40 | |     }
   | |_____^
note: ...so that reference does not outlive borrowed content
  --&gt; src/fifth.rs:35:17
   |
35 |                 self.head.as_deref_mut()
   |                 ^^^^^^^^^
note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 13:6...
  --&gt; src/fifth.rs:13:6
   |
13 | impl&lt;'a, T&gt; List&lt;'a, T&gt; {
   |      ^^
   = note: ...so that the expression is assignable:
           expected std::option::Option&lt;&amp;'a mut fifth::Node&lt;T&gt;&gt;
              found std::option::Option&lt;&amp;mut fifth::Node&lt;T&gt;&gt;


</code></pre>
<p>哇，这是一个非常详细的错误信息。这有点令人担忧，因为它表明我们正在做一些非常混乱的事
情。这里有一个有趣的部分：</p>
<blockquote>
<p>生命期必须对内联中定义的 &quot;a &quot;的生命期有效。</p>
</blockquote>
<p>我们借用了<code>self</code>，但编译器希望我们的生命期和<code>'a</code>一样长，如果我们告诉它<code>self</code><em>确实</em>
能持续那么久呢……？</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;'a mut self, elem: T) {
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `elem`
 --&gt; src/fifth.rs:9:5
  |
9 |     elem: T,
  |     ^^^^^^^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>哦，嘿，成功了! 很好!</p>
<p>我们也来做<code>pop</code>吧：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;'a mut self) -&gt; Option&lt;T&gt; {
    // Grab the list's current head
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        // If we're out of `head`, make sure to set the tail to `None`.
        if self.head.is_none() {
            self.tail = None;
        }

        head.elem
    })
}
</code></pre>
<p>并为此写一个快速测试：</p>
<pre><code class="language-rust ignore">mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:68:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
68 |         list.push(1);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:69:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
69 |         list.push(2);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:70:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
70 |         list.push(3);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here


....

** WAY MORE LINES OF ERRORS **

....

error: aborting due to 11 previous errors
</code></pre>
<p>🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀</p>
<p>哦，我的天哪。</p>
<p>编译器在我们身上呕吐是没有错的。我们刚刚犯了一个Rust的大罪：我们在<em>自己内部</em>存储了
一个对自己的引用。不知何故，我们成功地说服了Rust，在我们的<code>push</code>和<code>pop</code>实现中，这
完全是有意义的（我真的很震惊，我们做到了）。我相信原因是Rust还不能从<code>push</code>和<code>pop</code>
中分辨出引用是进入自己的--或者说，Rust根本就没有这个概念。引用到自己身上不能生效只
是一种突发行为。</p>
<p>当我们试图<em>使用</em>我们的列表时，一切都迅速崩溃了。当我们调用<code>push</code>或<code>pop</code>时，我们立
即在自己身上存储了一个对自己的引用，并被<em>困住</em>。我们实际上是在借用我们自己。</p>
<p>我们的<code>pop</code>实现暗示了为什么这可能是非常危险的：</p>
<pre><code class="language-rust ignore">// ...
if self.head.is_none() {
    self.tail = None;
}
</code></pre>
<p>如果我们忘记这样做呢？那么我们的尾巴就会指向<em>某个已经从列表中删除的节点</em>。这样的节
点会立即被释放，我们就会有一个悬空的指针，而Rust应该保护我们免受其害！</p>
<p>事实上，Rust正在保护我们远离这种危险。只是以一种非常...<strong>迂回</strong>的方式。</p>
<p>那么我们能做什么呢？回到<code>Rc&lt;RefCell&gt;&gt;</code>地狱？</p>
<p>拜托了。不，不。</p>
<p>不，我们要离开轨道，使用<em>原始指针</em>。我们的布局将看起来像这样：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;, // DANGER DANGER
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>就这样了。没有这种懦弱的参考-计算-动态-借贷-检查的废话! 真实。硬的。未经检查的。
指针。</p>
<p>让我们都成为C语言。让我们整天都是C。</p>
<p>我回来了。我准备好了。</p>
<p>你好，<code>unsafe</code>。</p>
<h1><a class="header" href="#不安全的rust" id="不安全的rust">不安全的Rust</a></h1>
<p>这是一个严肃、巨大、复杂和危险的话题。它是如此严重，以至于关于它，我写了
<a href="https://doc.rust-lang.org/nightly/nomicon/">一整本书</a>。</p>
<p>长话短说，只要你允许调用其他语言，<em>每一种</em>语言实际上都是不安全的，因为你可以让C做任
意的坏事。是的：Java、Python、Ruby、Haskell......每个人在面对外来函数接口（FFI）的
时候都是很不安全的。</p>
<p>Rust通过将自己分成两种语言来接受这一事实。安全的Rust和不安全的Rust。到目前为止，我
们只使用了安全的Rust。它是完全100%安全的......除了它可以FFI到不安全的Rust。</p>
<p>不安全的Rust是安全Rust的一个<em>超集</em>。它的所有语义和规则与安全Rust完全相同，你只是被
允许做一些<em>额外</em>的事情，这些事情是非常不安全的，可能会导致可怕的未定义行为，困扰着C。</p>
<p>同样，这是一个非常巨大的话题，有很多有趣的角落案例。我<em>真的</em>不想深入研究它（好吧，我
其实想。我已经研究了。<a href="https://doc.rust-lang.org/nightly/nomicon/">读那本书</a>）。这没关系，因为有了链表，我们实际上可以忽略
几乎所有的东西。</p>
<p>我们要使用的主要不安全工具是<em>原始指针</em>。原始指针基本上是C的指针。它们没有固有的别名规
则。它们没有生命期。它们可以是空的。它们可以是悬空的。它们可以指向未初始化的内存。它
们可以被转换为整数或从整数中转换。它们可以被转换为指向不同的类型。可变性？转换它。几
乎所有的东西都可以，这意味着几乎所有的东西都可能出错。</p>
<p>这是一些不好的东西，老实说，要是永远不用碰这些东西，你会活得更快乐。不幸的是，我们想写
链表，而链表是很糟糕的。这意味着我们将不得不使用不安全的指针。</p>
<p>有两种类型的原始指针：<code>*const T</code>和<code>*mut T</code>。这些是指C语言中的<code>const T*</code>和<code>T*</code>，但
我们真的不关心 C 语言认为它们是什么意思。你只能将<code>*const T</code>解除引用为<code>&amp;T</code>，但就像变
量的可变性一样，这只是对不正确使用的一种提示。最多只是意味着你必须先将<code>*const</code>转为
<code>*mut</code>。尽管如果你实际上没有权限去改变指针的引用，你会有一个糟糕的时间。</p>
<p>总之，当我们写一些代码时，我们会对此有更好的感觉。现在，
<code>*mut T == &amp;unchecked mut T</code>！</p>
<h1><a class="header" href="#基础" id="基础">基础</a></h1>
<p>好了，回到基本的问题上。我们如何构建我们的链表？</p>
<p>之前我们只是做了：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<p>但我们不再为<code>tail</code>使用Option：</p>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/fifth.rs:15:34
   |
15 |         List { head: None, tail: None }
   |                                  ^^^^ expected *-ptr, found enum `std::option::Option`
   |
   = note: expected type `*mut fifth::Node&lt;T&gt;`
              found type `std::option::Option&lt;_&gt;`
</code></pre>
<p>我们<em>可以</em>使用一个Option，但是与Box不同，<code>*mut</code>是可以置空的。这意味着它不能受益于
空指针的优化。相反，我们将使用<code>null</code>来表示无。</p>
<p>那么，我们怎样才能得到一个空指针呢？有几种方法，但我更喜欢使用
<code>std::ptr::null_mut()</code>。如果你愿意，你也可以用<code>0 as *mut _</code>，但这似乎<em>太乱了</em>。</p>
<pre><code class="language-rust ignore">use std::ptr;

// defns...

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `head`
 --&gt; src/fifth.rs:4:5
  |
4 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `tail`
 --&gt; src/fifth.rs:5:5
  |
5 |     tail: *mut Node&lt;T&gt;,
  |     ^^^^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `head`
  --&gt; src/fifth.rs:12:5
   |
12 |     head: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p><em>噓</em>编译器，我们很快就会用到它们。</p>
<p>好了，让我们继续写<code>push</code>。这一次，我们不是在插入后抓取一个<code>Option&lt;&amp;mut Node&lt;T&gt;&gt;</code>
，而是直接抓取一个<code>*mut Node&lt;T&gt;</code>到Box的内部。我们知道我们可以稳妥地这样做，因为盒子
里的内容有一个稳定的地址，即使我们把盒子移来移去。当然，这并不<em>安全</em>，因为如果我们直
接丢掉盒子，我们就会有一个指向已释放内存的指针。</p>
<p>我们如何从一个普通的指针变成一个原始指针呢？强制的! 如果一个变量被声明为一个原始指针，
那么一个普通的引用就会被强制放到它里面：</p>
<pre><code class="language-rust ignore">let raw_tail: *mut _ = &amp;mut *new_tail;
</code></pre>
<p>我们有我们需要的所有信息。我们可以把我们的代码翻译成，大约是以前的参考版本：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // .is_null checks for null, equivalent to checking for None
    if !self.tail.is_null() {
        // If the old tail existed, update it to point to the new tail
        self.tail.next = Some(new_tail);
    } else {
        // Otherwise, update the head to point to it
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `next` on type `*mut fifth::Node&lt;T&gt;`
  --&gt; src/fifth.rs:31:23
   |
31 |             self.tail.next = Some(new_tail);
   |             ----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; try dereferencing it: `(*self.tail).next`
</code></pre>
<p>嗯？我们有一个指向Node的指针，为什么我们不能得到<code>next</code>字段？</p>
<p>当你使用原始指针时，Rust是个混蛋。要访问一个原始指针的内容，它坚持要求我们手动地取消
引用它们，因为这是一个不安全的操作。所以让我们来做这个：</p>
<pre><code class="language-rust ignore">*self.tail.next = Some(new_tail);
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `next` on type `*mut fifth::Node&lt;T&gt;`
  --&gt; src/fifth.rs:31:23
   |
31 |             *self.tail.next = Some(new_tail);
   |             -----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; try dereferencing it: `(*self.tail).next`
</code></pre>
<p>呜运算符优先级。</p>
<pre><code class="language-rust ignore">(*self.tail).next = Some(new_tail);
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block
  --&gt; src/fifth.rs:31:13
   |
31 |             (*self.tail).next = Some(new_tail);
   |             ^^^^^^^^^^^^^^^^^ dereference of raw pointer
   |
   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior
</code></pre>
<p>这不应该是这么难的事。</p>
<p>还记得我说过不安全的Rust就像是安全Rust的FFI语言吗？那么，编译器希望我们明确地划分出
我们正在做的FFI-ing的地方。我们有两个选择。首先，我们可以把<em>整个</em>函数标记为不安全的
，在这种情况下，它就变成了一个不安全的Rust函数，只能在<code>unsafe</code>的上下文中调用。这不
是很好，因为我们希望我们的列表可以安全使用。其次，我们可以在我们的函数中写一个
<code>unsafe</code>的块，来划定FFI的边界。这就宣告了整个函数是安全的。让我们来做这件事：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // Put the box in the right place, and then grab a reference to its Node
    if !self.tail.is_null() {
        // If the old tail existed, update it to point to the new tail
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        // Otherwise, update the head to point to it
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
warning: field is never used: `elem`
  --&gt; src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>耶！</p>
<p>有意思的是，这是迄今为止我们<em>唯一</em>需要写不安全块的地方。我们到处都在做原始指针的事
情，这到底是怎么回事？</p>
<p>事实证明，当涉及到<code>unsafe</code>的时候，Rust是一个巨大的规则法学家的迂腐者。我们有理由
希望最大化安全的Rust程序集，因为那些程序是我们可以更有信心的。为了达到这个目的，
Rust仔细地划出了一个最小的不安全区域。请注意，我们在处理原始指针的所有其他地方都是
在<em>分配</em>它们，或者只是观察它们是否为空。</p>
<p>如果你从来没有真正解除过一个原始指针的引用，<em>那么这些事情是完全安全的</em>。你只是在读
写一个整数而已。唯一的一次，你可能会因为一个原始指针而陷入困境，那就是你真的解除了
对它的引用。所以Rust说<em>只有</em>这种操作是不安全的，而其他的都是完全安全的。</p>
<p>超强。迂腐。但在技术上是正确的。</p>
<p>然而，这引起了一个有趣的问题：尽管我们应该用<code>unsafe</code>块来限定不安全的范围，但它实际
上依赖于在块之外建立的状态。甚至是在函数之外！</p>
<p>这就是我所说的不安全<em>污点</em>。只要你在一个模块中使用<code>unsafe</code>，整个模块就会被不安全所
玷污。所有的东西都必须正确编写，以确保不安全代码的不变性得到维护。</p>
<p>这种污点是可以管理的，因为有<em>隐藏性</em>。在我们的模块之外，我们所有的结构字段都是完全私
有的，所以其他人不能以任意的方式乱用我们的状态。只要我们公开的API的组合没有导致坏事
发生，就外部观察者而言，我们所有的代码都是安全的 实际上，这与FFI的情况没有什么不同。
只要它暴露了一个安全的接口，没有人需要关心某个Python数学库是否向C语言脱壳。</p>
<p>总之，让我们继续讨论<code>pop</code>，它几乎是逐字逐句的参考版本：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        if self.head.is_none() {
            self.tail = ptr::null_mut();
        }

        head.elem
    })
}
</code></pre>
<p>我们再次看到另一种情况，安全是有状态的。如果我们在<em>这个</em>函数中未能将尾巴指针清空，
我们就不会看到任何问题。然而，随后对<code>push</code>的调用将开始写到悬空的尾巴上！</p>
<p>让我们来测试一下：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<p>这只是堆栈测试，但预期的<code>pop</code>结果被翻转过来。我还在最后添加了一些额外的步骤，以确保
<code>pop</code>中的尾部指针损坏情况不会发生。</p>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>完美！</p>
<h1><a class="header" href="#额外的废品" id="额外的废品">额外的废品</a></h1>
<p>现在<code>push</code>和<code>pop</code>已经写好了，其他的都和栈的情况完全一样。只有那些改变列表长度
的操作才需要真正担心尾部指针的问题。</p>
<p>所以让我们从我们的第二个列表中窃取所有的东西（一定要把预期的测试输出倒过来）：</p>
<pre><code class="language-rust ignore">// ...

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}




impl&lt;T&gt; List&lt;T&gt; {
    // ...

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}





#[cfg(test)]
mod test {
    // ...

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}

</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 15 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>向复制-粘贴编程致敬。</p>
<p>起初我以为我们要用IntoIter来捣乱，但我们还是很方便地按迭代顺序弹出了！</p>
<h1><a class="header" href="#最终代码-1" id="最终代码-1">最终代码</a></h1>
<p>好了，通过一个小小的不安全因素，我们成功地在时间上比简单的安全队列有了线性的改
善，而且我们成功地重用了安全堆栈中几乎所有的逻辑！</p>
<p>我们也<em>没有</em>写任何疯狂的Rc或RefCell的东西。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ptr;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }

    pub fn push(&amp;mut self, elem: T) {
        let mut new_tail = Box::new(Node {
            elem: elem,
            next: None,
        });

        let raw_tail: *mut _ = &amp;mut *new_tail;

        if !self.tail.is_null() {
            unsafe {
                (*self.tail).next = Some(new_tail);
            }
        } else {
            self.head = Some(new_tail);
        }

        self.tail = raw_tail;
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|head| {
            let head = *head;
            self.head = head.next;

            if self.head.is_none() {
                self.tail = ptr::null_mut();
            }

            head.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_deref() }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // Check the exhaustion case fixed the pointer right
        list.push(6);
        list.push(7);

        // Check normal removal
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#一个好的不安全的双链双向队列" id="一个好的不安全的双链双向队列">一个好的不安全的双链双向队列</a></h1>
<p>不，还是没有写这篇! 它真的只是没有那么多的指导意义。</p>
<p>如果你真的想了解更多，请阅读[Rustonomicon][]和<a href="https://github.com/rust-lang/rust/blob/master/library/alloc/src/collections/linked_list.rs">std::collections::LinkedList</a>的源代码！</p>
<h1><a class="header" href="#一堆笨链表" id="一堆笨链表">一堆笨链表</a></h1>
<p>好了。就这样吧。我们做了所有的列表。</p>
<p>啊哈哈哈哈</p>
<p>不</p>
<p>总会有更多的列表。</p>
<p>这一章是一个关于更多可笑的链接列表以及它们如何与Rust交互的鲜活的文件。</p>
<pre><code>TODO: BLIST?
TODO: SkipList?
TODO: std::channel? -- 这就像另一个完整的章节。或者是3。
</code></pre>
<p>This chapter is a living document of the more ridiculous linked lists and how
they interact with Rust.</p>
<ol>
<li><a href="infinity-double-single.html">双重单链表</a></li>
<li>TODO: BList?</li>
<li>TODO: SkipList?</li>
<li>TODO: std::channel? -- 这就像另一个完整的章节。或者是3。</li>
</ol>
<h1><a class="header" href="#双重单链表" id="双重单链表">双重单链表</a></h1>
<p>我们在处理双链表时很纠结，因为它们有纠结的所有权语义：没有一个节点严格地拥有任
何其他节点。然而，我们对此感到挣扎，因为我们带来了我们对什么<em>是</em>链表的先入为主
的概念。也就是说，我们假设所有的链接都在同一个方向。</p>
<p>相反，我们可以把我们的列表分成两半：一个向左走，一个向右走：</p>
<pre><code class="language-rust ignore">// lib.rs
// ...
pub mod silly1;     // NEW!
</code></pre>
<pre><code class="language-rust ignore">// silly1.rs
use second::List as Stack;

struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}
</code></pre>
<p>现在，我们不再有一个单纯的安全堆栈，而是有一个通用的列表。我们可以通过推送到任何
一个堆栈来向左或向右增长这个列表。我们还可以通过从一端弹出数值到另一端来沿着列表
“行走”。为了避免不必要的分配，我们将复制我们的安全堆栈的源码，以获得它的私有细节：</p>
<pre><code class="language-rust ignore">pub struct Stack&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; Stack&lt;T&gt; {
    pub fn new() -&gt; Self {
        Stack { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }
}

impl&lt;T&gt; Drop for Stack&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>然后只是重新设计一下<code>push</code>和<code>pop</code>：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: None,
    });

    self.push_node(new_node);
}

fn push_node(&amp;mut self, mut node: Box&lt;Node&lt;T&gt;&gt;) {
    node.next = self.head.take();
    self.head = Some(node);
}

pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.pop_node().map(|node| {
        node.elem
    })
}

fn pop_node(&amp;mut self) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
    self.head.take().map(|mut node| {
        self.head = node.next.take();
        node
    })
}
</code></pre>
<p>现在我们可以做我们自己的链表：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    fn new() -&gt; Self {
        List { left: Stack::new(), right: Stack::new() }
    }
}
</code></pre>
<p>我们还可以做一些常规的事情：</p>
<pre><code class="language-rust ignore">pub fn push_left(&amp;mut self, elem: T) { self.left.push(elem) }
pub fn push_right(&amp;mut self, elem: T) { self.right.push(elem) }
pub fn pop_left(&amp;mut self) -&gt; Option&lt;T&gt; { self.left.pop() }
pub fn pop_right(&amp;mut self) -&gt; Option&lt;T&gt; { self.right.pop() }
pub fn peek_left(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.left.peek() }
pub fn peek_right(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.right.peek() }
pub fn peek_left_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.left.peek_mut() }
pub fn peek_right_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.right.peek_mut() }
</code></pre>
<p>但最有趣的是，我们可以走来走去！</p>
<pre><code class="language-rust ignore">pub fn go_left(&amp;mut self) -&gt; bool {
    self.left.pop_node().map(|node| {
        self.right.push_node(node);
    }).is_some()
}

pub fn go_right(&amp;mut self) -&gt; bool {
    self.right.pop_node().map(|node| {
        self.left.push_node(node);
    }).is_some()
}
</code></pre>
<p>我们在这里返回布尔值，只是为了方便表明我们是否真的成功移动了。现在让我们测试一下
这个宝贝：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn walk_aboot() {
        let mut list = List::new();             // [_]

        list.push_left(0);                      // [0,_]
        list.push_right(1);                     // [0, _, 1]
        assert_eq!(list.peek_left(), Some(&amp;0));
        assert_eq!(list.peek_right(), Some(&amp;1));

        list.push_left(2);                      // [0, 2, _, 1]
        list.push_left(3);                      // [0, 2, 3, _, 1]
        list.push_right(4);                     // [0, 2, 3, _, 4, 1]

        while list.go_left() {}                 // [_, 0, 2, 3, 4, 1]

        assert_eq!(list.pop_left(), None);
        assert_eq!(list.pop_right(), Some(0));  // [_, 2, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(2));  // [_, 3, 4, 1]

        list.push_left(5);                      // [5, _, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(3));  // [5, _, 4, 1]
        assert_eq!(list.pop_left(), Some(5));   // [_, 4, 1]
        assert_eq!(list.pop_right(), Some(4));  // [_, 1]
        assert_eq!(list.pop_right(), Some(1));  // [_]

        assert_eq!(list.pop_right(), None);
        assert_eq!(list.pop_left(), None);

    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 16 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fourth::test::into_iter ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::basics ... ok
test third::test::iter ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>这是一个<em>手指</em>数据结构的极端例子，我们将某种手指维护到结构中，结果是可以支持对位
置的操作，时间与手指的距离成正比。</p>
<p>我们可以对手指周围的列表进行非常快速的修改，但是如果我们想在离手指很远的地方进行修
改，我们就必须一直走到那里。我们可以通过将元素从一个堆栈转移到另一个堆栈来永久地走
过去，或者我们可以用一个<code>&amp;mut</code>临时沿着链接走过去做改变。然而，<code>&amp;mut</code>永远不能回到
列表中去，而我们的手指却可以！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
