<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>布局 - 用太多链表写法学习Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="用太多链表写法学习Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li><a href="first.html"><strong aria-hidden="true">2.</strong> 一个不好的栈</a></li><li><ol class="section"><li><a href="first-layout.html" class="active"><strong aria-hidden="true">2.1.</strong> 布局</a></li><li><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> 新建</a></li><li><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> 所有权101</a></li><li><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> 推入</a></li><li><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> 弹出</a></li><li><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> 测试</a></li><li><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> 丢弃</a></li><li><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> 最终代码</a></li></ol></li><li><a href="second.html"><strong aria-hidden="true">3.</strong> 一个可以的栈</a></li><li><ol class="section"><li><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> 选项</a></li><li><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> 泛型</a></li><li><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> 选择</a></li><li><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> 进入遍历</a></li><li><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> 遍历</a></li><li><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> 可变遍历</a></li><li><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> 最终代码</a></li></ol></li><li><a href="third.html"><strong aria-hidden="true">4.</strong> 一个持久化的栈</a></li><li><ol class="section"><li><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> 布局</a></li><li><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> 基本</a></li><li><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> 丢弃</a></li><li><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> 最终代码</a></li></ol></li><li><a href="fourth.html"><strong aria-hidden="true">5.</strong> A Bad Safe Deque</a></li><li><ol class="section"><li><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> Layout</a></li><li><a href="fourth-building.html"><strong aria-hidden="true">5.2.</strong> Building</a></li><li><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> Breaking</a></li><li><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> Peek</a></li><li><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> Symmetric Cases</a></li><li><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> Iteration</a></li><li><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> Final Code</a></li></ol></li><li><a href="fifth.html"><strong aria-hidden="true">6.</strong> An Unsafe Queue</a></li><li><ol class="section"><li><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> Layout</a></li><li><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> Unsafe</a></li><li><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> Basics</a></li><li><a href="fifth-extras.html"><strong aria-hidden="true">6.4.</strong> Extras</a></li><li><a href="fifth-final.html"><strong aria-hidden="true">6.5.</strong> Final Code</a></li></ol></li><li><a href="sixth.html"><strong aria-hidden="true">7.</strong> An Ok Unsafe Deque</a></li><li><a href="infinity.html"><strong aria-hidden="true">8.</strong> A Bunch of Silly Lists</a></li><li><ol class="section"><li><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> The Double Single</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">用太多链表写法学习Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#基本数据布局" id="基本数据布局">基本数据布局</a></h1>
<p>好吧，那么什么是链表呢？基本上，它是一堆堆上的数据片(嘘，内核的人!)，它们依次指
向对方。链表是程序员不应该碰的东西，而函数式程序员却用它来做所有事情。那么，我们
应该向函数式程序员询问链表的定义，这似乎很公平。他们可能会给你类似下面的定义：</p>
<pre><code class="language-haskell">List a = Empty | Elem a (List a)
</code></pre>
<p>其内容大致为 &quot;一个列表要么是空的，要么是一个元素，后面是一个列表&quot;。这是一个递归
定义，表示为<em>和类型</em>，这是 &quot;一个可以有不同值的类型，这些值可能是不同的类型 &quot;的
花哨名字。Rust 称和类型为<code>枚举</code>! 如果你来自于类似C语言，这正是你所熟悉和喜爱的枚
举，但是是超速的。所以让我们把这个函数定义转录到Rust中吧!</p>
<p>现在，我们将避免使用泛型来保持简单。我们将只支持存储有符号的32位整数:</p>
<pre><code class="language-rust ignore">// in first.rs

// pub says we want people outside this module to be able to use List
pub enum List {
    Empty,
    Elem(i32, List),
}
</code></pre>
<p><em>呼</em>，我被淹没了。我们还是继续编译吧：</p>
<pre><code class="language-text">&gt; cargo build

error[E0072]: recursive type `first::List` has infinite size
 --&gt; src/first.rs:4:1
  |
4 | pub enum List {
  | ^^^^^^^^^^^^^ recursive type has infinite size
5 |     Empty,
6 |     Elem(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `first::List` representable
</code></pre>
<p>好吧，我不知道你是怎么想的，但我确实觉得被函数式编程社区背叛了。</p>
<p>如果我们真正检查一下错误信息（在我们克服了整个背叛的事情之后），我们可
以看到rustc实际上是在告诉我们如何解决这个问题：</p>
<blockquote>
<p>insert indirection (e.g., a <code>Box</code>, <code>Rc</code>, or <code>&amp;</code>) at some point to make <code>first::List</code> representable</p>
</blockquote>
<p>好吧，<code>box</code>。那是什么？让我们谷歌一下<code>rust box</code>...</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std::boxed::Box - Rust</a></p>
</blockquote>
<p>贴在这里...</p>
<blockquote>
<p><code>pub struct Box&lt;T&gt;(_);</code></p>
<p>A pointer type for heap allocation.
See the <a href="https://doc.rust-lang.org/std/boxed/">module-level documentation</a> for more.</p>
</blockquote>
<p><em>clicks link</em></p>
<blockquote>
<p><code>Box&lt;T&gt;</code>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p>
<p>Examples</p>
<p>Creating a box:</p>
<p><code>let x = Box::new(5);</code></p>
<p>Creating a recursive data structure:</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}
#}</code></pre></pre>
<blockquote>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{:?}&quot;, list);
}
</code></pre></pre>
<blockquote>
<p>This will print <code>Cons(1, Box(Cons(2, Box(Nil))))</code>.</p>
<p>Recursive structures must be boxed, because if the definition of Cons looked like this:</p>
<p><code>Cons(T, List&lt;T&gt;),</code></p>
<p>It wouldn't work. This is because the size of a List depends on how many elements are in the list, and so we don't know how much memory to allocate for a Cons. By introducing a Box, which has a defined size, we know how big Cons needs to be.</p>
</blockquote>
<p>Wow, uh. That is perhaps the most relevant and helpful documentation I have ever seen. Literally the first thing in the documentation is <em>exactly what we're trying to write, why it didn't work, and how to fix it</em>.</p>
<p>Dang, docs rule.</p>
<p>Ok, let's do that:</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    Elem(i32, Box&lt;List&gt;),
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>Hey it built!</p>
<p>...but this is actually a really foolish definition of a List, for a few reasons.</p>
<p>Consider a list with two elements:</p>
<pre><code class="language-text">[] = Stack
() = Heap

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty, *junk*)
</code></pre>
<p>There are two key issues:</p>
<ul>
<li>We're allocating a node that just says &quot;I'm not actually a Node&quot;</li>
<li>One of our nodes isn't heap-allocated at all.</li>
</ul>
<p>On the surface, these two seem to cancel each-other out. We allocate an
extra node, but one of our nodes doesn't need to be allocated at all.
However, consider the following potential layout for our list:</p>
<pre><code class="language-text">[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
</code></pre>
<p>In this layout we now unconditionally heap allocate our nodes. The
key difference is the absence of the <em>junk</em> from our first layout. What is
this junk? To understand that, we'll need to look at how an enum is laid out
in memory.</p>
<p>In general, if we have an enum like:</p>
<pre><code class="language-rust ignore">enum Foo {
    D1(T1),
    D2(T2),
    ...
    Dn(Tn),
}
</code></pre>
<p>A Foo will need to store some integer to indicate which <em>variant</em> of the enum it
represents (<code>D1</code>, <code>D2</code>, .. <code>Dn</code>). This is the <em>tag</em> of the enum. It will also
need enough space to store the <em>largest</em> of <code>T1</code>, <code>T2</code>, .. <code>Tn</code> (plus some extra
space to satisfy alignment requirements).</p>
<p>The big takeaway here is that even though <code>Empty</code> is a single bit of
information, it necessarily consumes enough space for a pointer and an element,
because it has to be ready to become an <code>Elem</code> at any time. Therefore the first
layout heap allocates an extra element that's just full of junk, consuming a
bit more space than the second layout.</p>
<p>One of our nodes not being allocated at all is also, perhaps surprisingly,
<em>worse</em> than always allocating it. This is because it gives us a <em>non-uniform</em>
node layout. This doesn't have much of an appreciable effect on pushing and
popping nodes, but it does have an effect on splitting and merging lists.</p>
<p>Consider splitting a list in both layouts:</p>
<pre><code class="language-text">layout 1:

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Elem C, ptr) -&gt; (Empty *junk*)

split off C:

[Elem A, ptr] -&gt; (Elem B, ptr) -&gt; (Empty *junk*)
[Elem C, ptr] -&gt; (Empty *junk*)
</code></pre>
<pre><code class="language-text">layout 2:

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, ptr) -&gt; (Elem C, *null*)

split off C:

[ptr] -&gt; (Elem A, ptr) -&gt; (Elem B, *null*)
[ptr] -&gt; (Elem C, *null*)
</code></pre>
<p>Layout 2's split involves just copying B's pointer to the stack and nulling
the old value out. Layout 1 ultimately does the same thing, but also has to
copy C from the heap to the stack. Merging is the same process in reverse.</p>
<p>One of the few nice things about a linked list is that you can construct the
element in the node itself, and then freely shuffle it around lists without
ever moving it. You just fiddle with pointers and stuff gets &quot;moved&quot;. Layout 1
trashes this property.</p>
<p>Alright, I'm reasonably convinced Layout 1 is bad. How do we rewrite our List?
Well, we could do something like:</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    ElemThenEmpty(i32),
    ElemThenNotEmpty(i32, Box&lt;List&gt;),
}
</code></pre>
<p>Hopefully this seems like an even worse idea to you. Most notably, this really
complicates our logic, because there is now a completely invalid state:
<code>ElemThenNotEmpty(0, Box(Empty))</code>. It also <em>still</em> suffers from non-uniformly
allocating our elements.</p>
<p>However it does have <em>one</em> interesting property: it totally avoids allocating
the Empty case, reducing the total number of heap allocations by 1. Unfortunately,
in doing so it manages to waste <em>even more space</em>! This is because the previous
layout took advantage of the <em>null pointer optimization</em>.</p>
<p>We previously saw that every enum has to store a <em>tag</em> to specify which variant
of the enum its bits represent. However, if we have a special kind of enum:</p>
<pre><code class="language-rust ignore">enum Foo {
    A,
    B(ContainsANonNullPtr),
}
</code></pre>
<p>the null pointer optimization kicks in, which <em>eliminates the space needed for
the tag</em>. If the variant is A, the whole enum is set to all <code>0</code>'s. Otherwise,
the variant is B. This works because B can never be all <code>0</code>'s, since it contains
a non-zero pointer. Slick!</p>
<p>Can you think of other enums and types that could do this kind of optimization?
There's actually a lot! This is why Rust leaves enum layout totally unspecified.
There are a few more complicated enum layout optimizations that Rust will do for
us, but the null pointer one is definitely the most important!
It means <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Vec</code>, and
several other important types in Rust have no overhead when put in an <code>Option</code>!
(We'll get to most of these in due time.)</p>
<p>So how do we avoid the extra junk, uniformly allocate, <em>and</em> get that sweet
null-pointer optimization? We need to better separate out the idea of having an
element from allocating another list. To do this, we have to think a little more
C-like: structs!</p>
<p>While enums let us declare a type that can contain <em>one</em> of several values,
structs let us declare a type that contains <em>many</em> values at once. Let's break
our List into two types: A List, and a Node.</p>
<p>As before, a List is either Empty or has an element followed by another List.
By representing the &quot;has an element followed by another List&quot; case by an
entirely separate type, we can hoist the Box to be in a more optimal position:</p>
<pre><code class="language-rust ignore">struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>Let's check our priorities:</p>
<ul>
<li>Tail of a list never allocates extra junk: check!</li>
<li><code>enum</code> is in delicious null-pointer-optimized form: check!</li>
<li>All elements are uniformly allocated: check!</li>
</ul>
<p>Alright! We actually just constructed exactly the layout that we used to
demonstrate that our first layout (as suggested by the official Rust
documentation) was problematic.</p>
<pre><code class="language-text">&gt; cargo build

warning: private type `first::Node` in public interface (error E0446)
 --&gt; src/first.rs:8:10
  |
8 |     More(Box&lt;Node&gt;),
  |          ^^^^^^^^^
  |
  = note: #[warn(private_in_public)] on by default
  = warning: this was previously accepted by the compiler but
    is being phased out; it will become a hard error in a future release!
</code></pre>
<p>:(</p>
<p>Rust is mad at us again. We marked the <code>List</code> as public (because we want people
to be able to use it), but not the <code>Node</code>. The problem is that the internals of
an <code>enum</code> are totally public, and we're not allowed to publicly talk about
private types. We could make all of <code>Node</code> totally public, but generally in Rust
we favour keeping implementation details private. Let's make <code>List</code> a struct, so
that we can hide the implementation details:</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
</code></pre>
<p>Because <code>List</code> is a struct with a single field, its size is the same as that
field. Yay zero-cost abstractions!</p>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/first.rs:2:5
  |
2 |     head: Link,
  |     ^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: variant is never constructed: `Empty`
 --&gt; src/first.rs:6:5
  |
6 |     Empty,
  |     ^^^^^

warning: variant is never constructed: `More`
 --&gt; src/first.rs:7:5
  |
7 |     More(Box&lt;Node&gt;),
  |     ^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/first.rs:11:5
   |
11 |     elem: i32,
   |     ^^^^^^^^^

warning: field is never used: `next`
  --&gt; src/first.rs:12:5
   |
12 |     next: Link,
   |     ^^^^^^^^^^

</code></pre>
<p>Alright, that compiled! Rust is pretty mad, because as far as it can tell,
everything we've written is totally useless: we never use <code>head</code>, and no one who
uses our library can either since it's private. Transitively, that means Link
and Node are useless too. So let's solve that! Let's implement some code for our
List!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="first.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="first-new.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="first.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="first-new.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
